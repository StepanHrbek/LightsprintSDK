// Realtime Radiosity Viewer vertex ubershader
//
// options controlled by program:
//  #define SHADOW_MAPS [0..10]
//  #define SHADOW_SAMPLES [0|1|2|4|8]
//  #define NOISE_MAP
//  #define LIGHT_DIRECT
//  #define LIGHT_DIRECT_MAP
//  #define LIGHT_INDIRECT_CONST
//  #define LIGHT_INDIRECT_COLOR
//  #define LIGHT_INDIRECT_MAP
//  #define MATERIAL_DIFFUSE_COLOR
//  #define MATERIAL_DIFFUSE_MAP
//  #define FORCE_2D_POSITION
//
// Workarounds for driver bugs of one vendor made it a mess, sorry.
//
// Copyright (C) Stepan Hrbek, Lightsprint 2006

#if SHADOW_MAPS>0
varying vec4 shadowCoord[SHADOW_MAPS];
#endif

#ifdef NOISE_MAP
varying vec2 fragCoord; // ATI switches to sw raster on gl_FragCoord
#endif

#ifdef LIGHT_DIRECT
uniform vec3 lightDirectPos;
varying vec4 lightDirectColor;
#endif

#ifdef LIGHT_INDIRECT_COLOR
varying vec4 lightIndirectColor; // passed rather through gl_FrontColor, ATI fails on anything else
#endif

#ifdef LIGHT_INDIRECT_MAP
varying vec2 lightIndirectCoord;
#endif

#ifdef MATERIAL_DIFFUSE_COLOR
varying vec4 materialDiffuseColor;
#endif

#ifdef MATERIAL_DIFFUSE_MAP
varying vec2 materialDiffuseCoord;
#endif

void main()
{
#ifdef LIGHT_DIRECT
  // direct light
  vec3 lightDirectDir = normalize(lightDirectPos - gl_Vertex.xyz);
  lightDirectColor = vec4(max(dot(lightDirectDir, normalize(gl_Normal)),0.0));
#endif

#ifdef LIGHT_INDIRECT_COLOR
  // indirect light
  gl_FrontColor = gl_Color;
#endif

#ifdef LIGHT_INDIRECT_MAP
  lightIndirectCoord = gl_MultiTexCoord1.xy;
#endif

#ifdef MATERIAL_DIFFUSE_MAP
  materialDiffuseCoord = gl_MultiTexCoord0.xy;
#endif

#ifdef MATERIAL_DIFFUSE_COLOR
  materialDiffuseColor = gl_SecondaryColor;
#endif

  // for cycle (for any OpenGL 2.0 compliant card)
  //for(int i=0;i<SHADOW_MAPS;i++)
  //  shadowCoord[i] = gl_TextureMatrix[i] * gl_Vertex;
  // unrolled version (ATI fails on for cycle)
#if SHADOW_MAPS>0
  shadowCoord[0] = gl_TextureMatrix[0] * gl_Vertex;
#endif
#if SHADOW_MAPS>1
  shadowCoord[1] = gl_TextureMatrix[1] * gl_Vertex;
#endif
#if SHADOW_MAPS>2
  shadowCoord[2] = gl_TextureMatrix[2] * gl_Vertex;
#endif
#if SHADOW_MAPS>3
  shadowCoord[3] = gl_TextureMatrix[3] * gl_Vertex;
#endif
#if SHADOW_MAPS>4
  shadowCoord[4] = gl_TextureMatrix[4] * gl_Vertex;
#endif
#if SHADOW_MAPS>5
  shadowCoord[5] = gl_TextureMatrix[5] * gl_Vertex;
#endif
#if SHADOW_MAPS>6
  shadowCoord[6] = gl_TextureMatrix[6] * gl_Vertex;
#endif
#if SHADOW_MAPS>7
  shadowCoord[7] = gl_TextureMatrix[7] * gl_Vertex;
#endif
#if SHADOW_MAPS>8
  shadowCoord[8] = gl_TextureMatrix[8] * gl_Vertex;
#endif
#if SHADOW_MAPS>9
  shadowCoord[9] = gl_TextureMatrix[9] * gl_Vertex;
#endif
  
#ifdef FORCE_2D_POSITION
  gl_Position = vec4(gl_MultiTexCoord7.x,gl_MultiTexCoord7.y,0.5,1.0);
#else
  gl_Position = ftransform();
#endif
#ifdef NOISE_MAP
  fragCoord = gl_Position.xy/gl_Position.w*vec2(800.0,600.0);
#endif
}

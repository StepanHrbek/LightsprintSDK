/**


\mainpage Lightsprint SDK
Welcome to Lightsprint libraries.

\subpage news "What's new"
 - what's new in releases

\subpage vision "Lightsprint VISION"
 - calculates radiosity / global illumination

\subpage collider "Lightsprint COLLIDER"
 - finds ray-mesh intersections

\subpage rules "Coding rules"
 - general rules for programming with SDK

\subpage platforms "Supported platforms"
 - platforms supported by Lightsprint



\page platforms Supported platforms

\section plat_bin Platforms for binaries
 At least parts of both \ref vision "Vision" and \ref collider "Collider" are
 delivered in compiled binary form.

 Supported platforms are
 - Win32
 - (fully tested also under Windows XP x64, where it runs in 32bit)

 Supported CPUs are
 - x86 compatible with SSE

 Binaries may work with multiple compilers, but only these are tested:
 - Visual C++ 2003
 - Visual C++ 2005

\section plat_src Platforms for source code
 With appropriate license, \ref collider "Collider" may be delivered 
 also in form of source code.

 Our source code conforms to standard <b>ISO C++</b>, so you should be 
 able to use Collider on nearly <b>any platform</b>.

 There are optional optimizations, that use SSE instructions on x86 CPUs,
 but they may be omitted on other platforms.


 
\page rules Coding rules
 These rules apply to all interfaces in SDK:
 - If not otherwise specified, all inputs must be finite numbers.
   With Inf or NaN, result is undefined.
 - Parameters that need to be destructed are always destructed by caller.
 - Library uses both floats and doubles.
   It is not allowed to break double arithmetics by modifying FPU states.
   If you use Direct3D, make sure you don't instruct it to force single precision for whole application.



\page vision Lightsprint Vision
 In typical situation, you have your own renderer with direct illumination.
 Vision can enhance it by adding indirect illumination.
 (\subpage vision_types "explanation")

 In atypical sutuation, Vision is also able to calculate global illumination
 without any relation to your renderer, however this case is not officially supported.

 Header: RRVision.h
 \n Namespace: rrVision

 - calculates global illumination in static scene
 - progressive refinement with permanent access to results
 - calculated illumination is available in vertices
 - applications can calculate illumination in realtime or use precalculated data
 - optimized for speed, usage in interactive environments
 - works with your units (screen colors or radiometry or photometry units or anything else)
 - display independent, purely numerical API

\subpage vision_types "Illumination types" and where is Vision

\subpage vision_integration "Integration with renderer" and how to start

\subpage vision_static "Static scenes"

\subpage vision_dynamic "Dynamic scenes"

\subpage vision_storage "Data formats"

\subpage vision_units "Units"

\image html ClassDiagram.png

\page vision_types Illumination types
 In our real world, we see visible light coming mostly from special surfaces 
 (hot wolfram fibre in bulb, luminofor of fluorescent lamp)
 or from whole volumes of plasma (sun, fire).
 We call these surfaces and volumes <b>source of direct illumination</b>.

 Light from sources of direct illumination reaches other surfaces 
 where part of light is absorbed and part is reflected.
 Reflected part is what makes objects look lit.
 We call reflected part <b>direct illumination</b>.

 Light from direct illumination reaches other surfaces, partially reflects,
 reaches other surfaces, partially reflects etc.
 We call sum of reflected parts <b>indirect illumination</b>.

 Illumination is sum of direct and indirect illumination.

 Computer graphics tries to simulate this process in order to generate realistic images.
 This is however very time consuming process.
 So realtime computer graphics in 99% of cases resigns to real-world sources of direct 
 illumination and uses imaginary <b>"point" or "directional" lights</b>.
 These fictitious sources of direct illumination
 allow realtime computer graphics to calculate direct illumination very quickly.
 This process includes calculation of <b>shadows in direct illumination</b>.
 There are many realtime techniques for calculating shadows in direct illumination,
 most notably shadow mapping.

 There is however still problem with indirect illumination, which remains
 hard to compute quickly.

 You are expected to <b>have renderer with direct illumination and shadows</b> in 
 direct illumination. This is very modest expectation, as there are
 many realtime renderers having it, both commercial and open source.

 <b>Vision is a tool for calculating indirect illumination</b> for such renderer.

 Vision is also able to calculate complete illumination (direct+indirect)
 from real-world direct light sources - surfaces. However we don't encourage
 this use case, library is not optimized for this task.

\page vision_integration Integration with renderer
 Three steps to integrate Vision with your renderer are described in
 <a href="http://dee.cz/rri">Realtime Radiosity Integration article</a>.

 This will be further documented in examples later.

 After reading article, you may want to get familiar with some interfaces.
 Sample HelloVision shows you some of them on the most simple use case:
 -# Show your license number to rrVision::RRLicense.
 -# Create rrVision::RRScene.
 -# Create rrVision::RRObjectImporter using your object and insert it into scene. Repeat for all objects.
 -# Calculate global illumination using rrVision::RRScene::illuminationImprove().
 -# Read results using rrVision::RRScene::getTriangleMeasure().

\page vision_static Static scenes
 It is recommended to integrate Vision to your editor,
 precalculate illumination there (using any target quality you need),
 store it and use only precalculated data in your final product.
 This way you don't need to link Vision libraries to your product, only to your editor.

\page vision_dynamic Dynamic scenes
 Vision can quickly recalculate illumination after each change in dynamic scene.
 However quality oscilates, so this is feasible only for few applications.

 For games and most of other applications with absolutely strict requirements 
 for illumination quality, it is necessary to precalculate wisely in editor 
 and use only precalculated data in final product.

 This is very application dependant, but some general hints apply for everyone.

 \section independent_lights Independent lights
   You can have multiple lightsources which can be turned on/off independently.
   In this case, precalculate indirect illumination for each one separately.
   Later in final product render only contributions of those lights turned on.
   For renderer, this requires only summing several numbers for each vertex.
   Sums can also be precalculated, because they change rarely, so this would
   have no impact on rendering speed.

 \section moving_lights Moving lights
   You can have lights moving in some known area, eg. sun with known trajectory or
   hanging lamp swinging in multiple directions.
   In this case, select few points on trajectory and precalculate indirect illumination 
   for those samples.
   Later in final product interpolate between closest samples, depending on light
   position. This can be precalculated for slowly moving lights (sun) and have no
   impact on rendering speed. For quickly moving lights, this must be done in vertex
   shader, but as it is only linear interpolation of (typically) two numbers, 
   it has nearly no impact on performance.
   
 \section moving_objects Moving objects
   For most of objects, changes in indirect illumination while they move are so small, 
   that it is often adequate to ignore their contribution.
   However there are cases when moving object makes fundamental change in illumination.
   This could be door from lit room to dark room. When they are closed, dark room is
   completely dark. As they open, dark room receives lots of indirect illumination.
   In this case, select few points on door trajectory and precalculate indirect illumination 
   for those samples.
   Later in final product interpolate between closest samples, depending on door
   position. This requires only linear interpolation of two numbers,
   so it has nearly no impact on performance.

\page vision_storage Data formats
 Illumination levels are calculated for all surfaces in your scene.
 Several ways how to access these information and how to store them exist,
 each with advantages and disadvantages.
 \section vertices Vertices
   Now you may read illumination levels in face vertices.
   It is expected that illumination inside face will be interpolated
   from values in vertices.
   \n This representation has several advantages:
   - It is cheap for storing. It requires only few bytes of space per vertex.
   - It is cheap for rendering.
     No sampler resources are consumed.
     It can be arbitrarily postprocessed in vertex shader.
     You may have for example multiple layers of precalculated indirect illumination 
     and mix them in vertex shader according to changes in scene.

   On the other hand, there are all known disadvantages of vertex illumination:
   - Details are missing in areas without vertices.
     For good results, you have to add vertices to places where you miss details.
   - Seams around T vertices and other degenerated geometries.
     You have to make your meshes clean, avoid degeneracies.
   - Long narrow triangles often create visible artifacts.
     You should avoid them.
 \section textures Textures
   In future versions, it will be possible to store illumination levels
   into texture covering all surfaces.
   This representation is more expensive for processing, storage and rendering
   (any postprocessing must be done per pixel and it consumes sampler resources),
   but avoids disadvantages of vertex illumination.

\page vision_units Units
   Although whole documentation talks in radiometry terms,
   it is possible to work in photometry units, screen colors 
   or any other units.
   In typical situations, it is most straightforward to work and think 
   in screen colors. Everything you need is to setup appropriate
   convertor, see rrVision::RRScene::setScaler().



\page collider Lightsprint Collider
 Finds ray-mesh intersections.

 Header: RRCollider.h
 \n Namespace: rrCollider

\section collider1 Library overview
 - thread safe, you can calculate any number of intersections at the same time
 - you can select technique in range from maximal speed to zero memory allocated
 - up to 2^32 vertices and 2^30 triangles in mesh
 - builds helper-structures and stores them in cache on disk

\section collider3 Basic usage scenario
 -# Show your license number to rrCollider::RRLicense.
 -# Create rrCollider::RRMeshImporter using your mesh.
 -# Create rrCollider::RRCollider using your mesh importer.
 -# Create rrCollider::RRRay using your ray.
 -# Call rrCollider::RRCollider::intersect() to find intersections. Repeat for all rays.



\page news What's new

\section news3 2006.4.xx

NEW FEATURES

CHANGES

- new scheduler in radiosity solver
  \n rrVision::RRScene::illuminationReset() supports preserving factors
  \n 5% faster calculation on average

\section news3 2006.3.23

NEW FEATURES

- rrCollider::RRMeshImporter::MultiMeshPreImportNumber
  \n defines format of PreImport index in MultiMesh
  \n simplifies work with MultiMeshes created by rrCollider::RRMeshImporter::createMultiMesh()
- rrCollider::RRVec2 newly equipped with arithmetic operators
  \n simplifies work with 2d vectors

CHANGES

- column-major RRMatrix4x4 replaced by row-major rrVision::RRMatrix3x4
- on several places, behaviour is defined for invalid inputs
- improved documentation


\section news2 2006.3.10

NEW FEATURES

- sample "HelloVision"
  \n performs minimalistic illumination calculation
  \n gives first insight into Vision usage


\section news1 2006.2.26

NEW FEATURES

- documentation
- rrVision::RRSideBits
  \n precise surface behaviour control
  \n allows to simulate new range of surfaces
- rrVision::RRScaler
  \n automatic input and output scaling
  \n simplifies work with any units including radiometric,
  photometric and linear screen space
- rrVision::RRRadiometricMeasure
  \n more general interface to many inputs and outputs
  \n simplifies data transfers
- rrCollider::RRMeshImporter::verify()
  \n mesh importer correctness verification
  \n simplifies testing mesh data and writing new importers
- rrVision::RRAdditionalObjectImporter
  \n simplifies transfer of captured direct illumination
- rrCollider::RRVec2, rrCollider::RRVec3, rrCollider::RRVec4, rrVision::RRMatrix4x4
  \n primitives with basic mathematics
  \n simplifies inputs and outputs, adds type control
- rrVision::RRSceneStatistics
  \n new statistics of scene processing
  \n gives insight into processing when needed

CHANGES

- +2% faster on average
- more input data verifications during calculation
- \#define RR*_IMPORT no longer needed

*/

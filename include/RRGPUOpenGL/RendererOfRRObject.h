// --------------------------------------------------------------------------
// Renderer implementation that renders RRObject instance.
// Copyright (C) Stepan Hrbek, Lightsprint, 2005-2007
// --------------------------------------------------------------------------

#ifndef RENDEREROFRROBJECT_H
#define RENDEREROFRROBJECT_H

#include <cstring> // memset
#include "RRVision.h"
#include "DemoEngine/Renderer.h"
#include "RRGPUOpenGL.h"

namespace rr_gl
{

// Custom channels supported by RendererOfRRObject.
// (they allocate channel numbers not used by Lightsprint engine)
enum
{
	CHANNEL_SURFACE_DIF_TEX              = rr::RRMesh::INDEXED_BY_SURFACE+1,  ///< channel contains Texture* for each surface
	CHANNEL_TRIANGLE_VERTICES_DIF_UV     = rr::RRMesh::INDEXED_BY_TRIANGLE+5, ///< channel contains RRVec2[3] for each triangle
	CHANNEL_TRIANGLE_OBJECT_ILLUMINATION = rr::RRMesh::INDEXED_BY_TRIANGLE+6, ///< channel contains RRObjectIllumination* for each triangle
};


//////////////////////////////////////////////////////////////////////////////
//
// per vertex data generator

//! Generator of per vertex data, for internal use.
class VertexDataGenerator
{
public:
	virtual ~VertexDataGenerator() {};
	// generates vertex data into 'size' bytes of 'vertexData'
	virtual void generateData(unsigned triangleIndex, unsigned vertexIndex, void* vertexData, unsigned size) = 0; // vertexIndex=0..2
	// returns hash of all parameters that modify generateData behaviour.
	virtual unsigned getHash() = 0;
};


//////////////////////////////////////////////////////////////////////////////
//
// RendererOfRRObject

//! OpenGL renderer of 3d object with RRObject interface.
//
//! Renders RRObject instance.
//! Feeds OpenGL with primitives and binds textures,
//! expects that shaders were already set.
//! 
//! Why does it exist?
//! - It can render each triangle with independent generated uv coords,
//!   without regard to other triangles that share the same vertex.
//! - This special feature is useful during detectDirectIllumination()
//!   and for ambient mapped render with autogenerated ambient map unwrap.
//!
//! Other ways how to reach the same without second renderer:
//! - Stay with any other renderer you have.
//!   Don't share vertices, resave all your meshes with vertices splitted.
//!   This makes mesh bigger and rendering bit slower,
//!   but uv coord may be set for each triangle independently.
//!   You can eventually store both versions of mesh and render
//!   the bigger one only during detectDirectIllumination().
//! - Stay with any other renderer that supports geometry shaders.
//!   Write simple geometry shader that generates uv.
class RR_API RendererOfRRObject : public de::Renderer
{
public:
	//! Creates renderer of object.
	//! \param object
	//!  Object to be rendered.
	//! \param radiositySolver
	//!  Solver used to compute object's indirect illumination.
	//! \param scaler
	//!  Scaler used to scale irradiances before rendering from physical scale to custom scale.
	//! \param useBuffers
	//!  Set true for rendering technique with vertex buffers. Makes rendering faster,
	//!  but only if it's done many times repeatedly. More memory is needed.
	//!  If you plan to render object only once,
	//!  technique without buffers (false) is faster and takes less memory.
	RendererOfRRObject(const rr::RRObject* object, const rr::RRScene* radiositySolver, const rr::RRScaler* scaler, bool useBuffers);

	//! Specifies what data channels to feed to GPU during render.
	struct RenderedChannels
	{
		bool     LIGHT_DIRECT           :1; ///< feeds gl_Normal
		bool     LIGHT_INDIRECT_COLOR   :1; ///< feeds gl_Color
		bool     LIGHT_INDIRECT_MAP     :1; ///< feeds gl_MultiTexCoord[MULTITEXCOORD_LIGHT_INDIRECT] + texture[TEXTURE_2D_LIGHT_INDIRECT]
		bool     LIGHT_INDIRECT_ENV     :1; ///< feeds gl_Normal + texture[TEXTURE_CUBE_LIGHT_INDIRECT]
		bool     MATERIAL_DIFFUSE_COLOR :1; ///< feeds gl_SecondaryColor
		bool     MATERIAL_DIFFUSE_MAP   :1; ///< feeds gl_MultiTexCoord[MULTITEXCOORD_MATERIAL_DIFFUSE] + texture[TEXTURE_2D_MATERIAL_DIFFUSE]
		bool     FORCE_2D_POSITION      :1; ///< feeds gl_MultiTexCoord[MULTITEXCOORD_FORCED_2D]
		//! Creates setup with everything off, only vertex positions are rendered.
		//! Suitable for rendering into shadowmaps.
		RenderedChannels()
		{
			memset(this,0,sizeof(*this));
		}
	};

	//! Sets what data channels to feed to GPU during render().
	void setRenderedChannels(RenderedChannels renderedChannels);

	//! Sets source of uv coords for render() with FORCE_2D_POSITION enabled.
	void setCapture(VertexDataGenerator* capture, unsigned afirstCapturedTriangle, unsigned alastCapturedTrianglePlus1);

	//! Sets global illumination buffers for whole scene.
	//! Used by render() with LIGHT_INDIRECT_COLOR or LIGHT_INDIRECT_MAP,
	//! but only if renderer was created with useBuffers=true.
	void setIndirectIllumination(rr::RRIlluminationVertexBuffer* vertexBuffer,rr::RRIlluminationPixelBuffer* ambientMap);

	//! Returns parameters with influence on render().
	virtual const void* getParams(unsigned& length) const;

	//! Renders object, feeds OpenGL with object's data selected by setRenderedChannels().
	//! Doesn't set any shader, expects that it was already set by caller.
	virtual void render();

	virtual ~RendererOfRRObject();

private:
	friend class ObjectBuffers;
	struct Params
	{
		const rr::RRObject* object;            ///< object being rendered
		const rr::RRScene* scene;              ///< scene it comes from
		const rr::RRScaler* scaler;            ///< scaler used to translate physical to custom irradiance when LIGHT_INDIRECT_COLOR
		RenderedChannels renderedChannels;     ///< set of data channels being rendered
		VertexDataGenerator* generateForcedUv; ///< generator of uv data for FORCE_2D_POSITION
		unsigned otherCaptureParamsHash;       ///< hash of generator's parameters
		unsigned firstCapturedTriangle;        ///< index of first triangle to render
		unsigned lastCapturedTrianglePlus1;    ///< index of last triangle to render+1
		rr::RRIlluminationVertexBuffer* indirectIllumination;   ///< vertex buffer with indirect illumination
		rr::RRIlluminationPixelBuffer* indirectIlluminationMap; ///< ambient map
	};
	Params params;
	// buffers for faster rendering
	class ObjectBuffers* indexedYes;
	class ObjectBuffers* indexedNo;
};

}; // namespace

#endif

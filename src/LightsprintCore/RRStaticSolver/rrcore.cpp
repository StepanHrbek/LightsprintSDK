// --------------------------------------------------------------------------
// Radiosity solver - low level.
// Copyright 2000-2008 Stepan Hrbek, Lightsprint. All rights reserved.
// --------------------------------------------------------------------------

#include <assert.h>
#ifndef _MSC_VER
#include <inttypes.h> // intptr_t
#endif
#include <math.h>
#include <memory.h>
#ifdef _OPENMP
#include <omp.h> // known error in msvc manifest code: needs omp.h even when using only pragmas
#endif
#include <stdarg.h>
#include <stddef.h>   // intptr_t
#include <stdio.h>    // printf na debugink
#include <stdlib.h>
#include <string.h>
#include <time.h>     // gate
//#include "libff/ff.h"
#include "../LicGen.h"
#include "rrcore.h"
#include "clusters.h"

/*/ asserts also in release
#include <windows.h>
#undef assert
#define RR_ASSERT(a) {if(!(a)) DebugBreak();}*/

namespace rr
{

#define ALLOW_DEGENS                 // accept triangles degenerated by low numerical quality float operations
#define HOMOGENOUS_FILL              // shooting direction is not random but fractal, 0% space, -2% calc
#define CLEAN_FACTORS                // pure geometry factors not multiplied by destination material, -1%calc (YES = allows calculations with different components, NO = allows full clustering, factors may direct to clusters)
#define MESHING              RRStaticSolver::getStateF(RRStaticSolver::SUBDIVISION_SPEED)    // 0.3=few meshes, 1=default, 3=many meshes (noise)
#define REFLECTOR_MESHING    2.5     // 1=no subreflectors, 10=possibility of many meshes
#define SHOOT_FULL_RANGE     1       // 89/90=ignore 1 degree near surface, shoot only away from surface (to avoid occasional shots inside object)
#define HITS_TO_COMPACT      1000000 // if more or equal bytes may be freeed, do it after each shooting. may help to save memory for big scenes. warning: low number=+10%cpu
#define REFRESH_FIRST          1     // first refresh has this number of photons (zahada: vyssi cislo rrbench zpomaluje misto zrychluje)
#define REFRESH_MULTIPLY       4     // next refresh has multiplied number of photons
#define MAX_REFRESH_DISBALANCE 5     // higher = faster, but more dangerous
#define DISTRIB_LEVEL_HIGH     0.0003 // higher fraction of scene energy found in one node starts distribution
#define DISTRIB_LEVEL_LOW      0.000003// lower fraction of scene energy found in one node is ignored
// DISTRIB_LEVEL 0.003 / 0.0001 byl moc velky ve fcss/koupelne.
//  popis: po spusteni je pod kouli moc svetla.
//  po resetStaticIllum ve chvili kdy mam jeste primitivni faktory se zas objevi moc svetla.
//  i kdyz necham dlouho zlepsovat faktory, svetla zustane moc.
//  po resetStaticIllum ve chvili kdyz uz mam dobry faktory zmizi a uz trvale zustane moc malo svetla.
//  pokud v resetStaticIllum jen updatuju, nadbytecne svetlo zustane prilepene a zmizi az kdyz hlavni lampou posvitim extremne do cerna.
// DISTRIB_LEVEL_LOW 0.00003 byl moc velky v sibeniku
//  popis: po spocitani indirectu a presunu svetla jinam indirect nezmizel, protoze byl asi prilis slaby
// DISTRIB_LEVEL_HIGH 0.00003 byl moc maly v sibeniku
//  po kazdem refreshi nasledovala tuna distribu, brutalni zpomaleni
// !!! nutno resit adaptivne
//  pri priprave bestu vzdy skouknout refreshe i distriby a rozhodnout se kteri jsou ted lepsi
//#define DEBUK
//#define LOG_LOADING_MES
//#define EXPENSIVE_CHECKS
//#define SUPPORT_NEGATIVE_LIGHT // support negative values in additionalIrradiance, reset(), getTriangleMeasure() [used for bent normals pertriangle->pervertex]

#define TWOSIDED_RECEIVE_FROM_BOTH_SIDES
#define TWOSIDED_EMIT_TO_BOTH_SIDES
#define ONESIDED_TRANSMIT_ENERGY

//////////////////////////////////////////////////////////////////////////////
//
// license

bool                     licenseStatusValid = false;
RRLicense::LicenseStatus licenseStatus = RRLicense::WRONG;

//////////////////////////////////////////////////////////////////////////////
//
// memory

#define SIMULATE_REALLOC

void* realloc(void* p,size_t oldsize,size_t newsize)
{
#ifdef SIMULATE_REALLOC
	//if(newsize>500000) return realloc(p,newsize);
	// this simulated realloc prevents real but buggy realloc from crashing rr (seen in DJGPP)
	// it is also faster (seen in MinGW)
	void *q=malloc(newsize);
	if(!q)
	{
		RRReporter::report(ERRO,"Out of memory, exiting!\n");
		exit(0);
	}
	if(p)
	{
		memcpy(q,p,MIN(oldsize,newsize));
		free(p);
	}
	return q;
#else
	return ::realloc(p,newsize);
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// globals

bool  __errors=false; // was there errors during batch work? used to set result

unsigned  __frameNumber=1; // frame number increased after each draw


//////////////////////////////////////////////////////////////////////////////
//
// hit to subtriangle

real Hit::getPower()
{
	return power;
}

void Hit::setPower(real apower)
{
	RR_ASSERT(apower>=-1 && apower<=1);
	power=apower;
}

//////////////////////////////////////////////////////////////////////////////
//
// hits to one subtriangle

unsigned __hitsAllocated=0;

Hits::Hits()
{
	hitsAllocated=0;
	hit=NULL;
	reset();
}

void Hits::reset()
{
	hits=0;
	sum_u=0;
	sum_v=0;
	sum_power=0;
}

void Hits::rawInsert(Hit HIT_PTR ahit)
{
	STATISTIC_INC(numHitInserts);
	if(!hitsAllocated)
	{
		hitsAllocated=16;
		hit=(Hit *)malloc(hitsAllocated*sizeof(Hit));
		__hitsAllocated+=hitsAllocated;
	}
	else
	if(hits==hitsAllocated)
	{
		size_t oldsize=hitsAllocated*sizeof(Hit);
		__hitsAllocated+=3*hitsAllocated;
		hitsAllocated*=4;
		hit=(Hit *)realloc(hit,oldsize,hitsAllocated*sizeof(Hit));
	}
	hit[hits++]=ahit;
	sum_u+=ahit.u;
	sum_v+=ahit.v;
	sum_power+=ahit.power;
	RR_ASSERT(IS_POWER(ahit.power));
}

void Hits::insertWithSubdivision(Hit HIT_PTR ahit)
{
	rawInsert(ahit);
}

void Hits::insertWithoutSubdivision(HitChannels apower)
{
	hits++;
	sum_power+=apower;
}

real Hits::difBtwAvgHitAnd(Point2 a,Triangle *base)
{
	return size(Point2(sum_u/hits-a.x,sum_v/hits-a.y));
}

bool Hits::doSplit(Point2 centre,real perimeter,Triangle *base)
{
	return perimeter>1 && perimeter<difBtwAvgHitAnd(centre,base)*hits*base->object->subdivisionSpeed;
}

/*real Hits::avgDifBtwHitAnd(Point2 a)
{
	real dif=0;
	for(unsigned i=0;i<count;i++)
		dif+=size(Point2(hit[i].u-a.x,hit[i].v-a.y));
	return dif/count;
}*/

real Hits::totalPower()
{
	RR_ASSERT(IS_NUMBER(sum_power));
	return sum_power;
}

void Hits::compactImmediate()
{
	if(hitsAllocated && !hits)
	{
		free(hit);
		hit=NULL;
		__hitsAllocated-=hitsAllocated;
		hitsAllocated=0;
	}
}

void Hits::compact()
{
	if(hitsAllocated>=HITS_TO_COMPACT) compactImmediate();
}

Hits::~Hits()
{
	hits=0;
	compactImmediate();
}

//////////////////////////////////////////////////////////////////////////////
//
// form factor from implicit source to explicit destination

Factor::Factor(class Node *adestination,real apower)
{
	RR_ASSERT(apower>0); // power=0 has no sense to store
	// Power muze byt vic nez 1 uplne kdykoliv, viz komentar u rayTracePhoton().
	//RR_ASSERT(apower<=1 || adestination->grandpa->surface->specularTransmittance>0); // power>1 may occur only on transparent surfaces
	power=apower;
	destination=adestination;
}

//////////////////////////////////////////////////////////////////////////////
//
// all form factors from implicit source

unsigned __factorsAllocated=0;

Factors::Factors()
{
	factors24_allocated8=0;
	factor=NULL;
}

unsigned Factors::factors()
{
	return factors24_allocated8>>8;
}

unsigned Factors::factorsAllocated()
{
	return 1<<(factors24_allocated8&0xff);
}

void Factors::insert(Factor afactor)
{
	if(!factors24_allocated8)
	{
		factors24_allocated8=4;
		factor=(Factor *)malloc(factorsAllocated()*sizeof(Factor));
		__factorsAllocated+=factorsAllocated();
	}
	else
	if(factors()==factorsAllocated())
	{
		size_t oldsize=factorsAllocated()*sizeof(Factor);
		__factorsAllocated+=3*factorsAllocated();
		factors24_allocated8+=2;
		factor=(Factor *)realloc(factor,oldsize,factorsAllocated()*sizeof(Factor));
	}
	factor[factors()]=afactor;
	factors24_allocated8+=0x100;
}

void Factors::insert(Factors *afactors)
{
	if(!afactors->factors()) return;
	if(!factors24_allocated8)
	{
		factors24_allocated8=4;
		while(factorsAllocated()<factors()+afactors->factors()) factors24_allocated8++;
		factor=(Factor *)malloc(factorsAllocated()*sizeof(Factor));
		__factorsAllocated+=factorsAllocated();
	}
	else
	if(factorsAllocated()<factors()+afactors->factors())
	{
		size_t oldsize=factorsAllocated()*sizeof(Factor);
		while(factorsAllocated()<factors()+afactors->factors())
		{
			__factorsAllocated+=factorsAllocated();
			factors24_allocated8++;
		}
		factor=(Factor *)realloc(factor,oldsize,factorsAllocated()*sizeof(Factor));
	}
	memcpy(&factor[factors()],&afactors->factor[0],afactors->factors()*sizeof(Factor));
	factors24_allocated8+=afactors->factors()<<8;
}

Factor Factors::get()
{
	RR_ASSERT(factors());
	factors24_allocated8-=0x100;
	return factor[factors()];
}

real Factors::contains(Node *destination)
{
	for(unsigned i=0;i<factors();i++) if(factor[i].destination==destination)
	{
		return factor[i].power;
	}
	return -1;
}

void Factors::remove(Factor *afactor)
{
	RR_ASSERT(afactor>=factor && afactor<factor+factors());
	*afactor=factor[factors()-1];
	factors24_allocated8-=0x100;
}

void Factors::forEach(void (*func)(Factor *factor,va_list ap),...)
{
	va_list ap;
	va_start(ap,func);
	for(unsigned i=0;i<factors();i++) func(factor+i,ap);
	va_end(ap);
}

void Factors::forEachDestination(void (*func)(Node *node,va_list ap),...)
{
	va_list ap;
	va_start(ap,func);
	for(unsigned i=0;i<factors();i++) func(factor[i].destination,ap);
	va_end(ap);
}

void Factors::removeZeroFactors()
{
	for(int i=factors()-1;i>=0;i--)
	{
		if(!factor[i].destination)
		{
			factors24_allocated8-=0x100;
			factor[i]=factor[factors()];
		}
	}
}

void Factors::reset()
{
	factors24_allocated8&=0xff;
}

Factors::~Factors()
{
	if(factors24_allocated8)
	{
		free(factor);
		RR_ASSERT(__factorsAllocated>=factorsAllocated());
		__factorsAllocated-=factorsAllocated();
	}
}

Shooter::Shooter()
{
	reset(true);
}

void Shooter::reset(bool resetFactors)
{
	if(resetFactors)
	{
		Factors::reset();
		shotsForFactors=0;
	}
	totalExitingFluxDiffused=Channels(0);
	totalExitingFluxToDiffuse=Channels(0);
}

real Shooter::accuracy()
{
	return shotsForFactors/(sum(abs(totalExitingFluxDiffused+totalExitingFluxToDiffuse))+SMALL_ENERGY);
}

Shooter::~Shooter()
{
}

//////////////////////////////////////////////////////////////////////////////
//
// LevelHits
//  each Triangle has its own Hits
//  SubTriangles allocate Hits here and return them here as soon as possible

class LevelHits
{
public:
	LevelHits();
	~LevelHits();

	Hits *allocLevel();
	void freeLevel();

	private:
		unsigned levelsAllocated;
		unsigned levels;
		Hits **level;
};

LevelHits::LevelHits()
{
	levels=0;
	levelsAllocated=0;
	level=NULL;
}

Hits *LevelHits::allocLevel()
{
	if(levels==levelsAllocated)
	{
		size_t oldsize=levelsAllocated*sizeof(Hits *);
		levelsAllocated+=16;
		level=(Hits **)realloc(level,oldsize,levelsAllocated*sizeof(Hits *));
		for(unsigned i=levels;i<levelsAllocated;i++)
			level[i]=new Hits;
	}
	RR_ASSERT(!level[levels]->hits);
	return level[levels++];
}

void LevelHits::freeLevel()
{
	RR_ASSERT(levels);
	RR_ASSERT(!level[levels-1]->hits);
	levels--;
}

LevelHits::~LevelHits()
{
	while(levelsAllocated--) delete level[levelsAllocated];
	free(level);
}

Hits* Scene::allocHitsLevel()
{
	return sceneLevelHits->allocLevel();
}

void Scene::freeHitsLevel()
{
	sceneLevelHits->freeLevel();
}

//////////////////////////////////////////////////////////////////////////////
//
// node in hierarchy of clusters, triangles and subtriangles

unsigned __nodesAllocated=0;

Node::Node(Node *aparent,class Triangle *agrandpa)
{
	parent=aparent;
	grandpa=agrandpa;
	shooter=parent?NULL:new Shooter();
	sub[0]=NULL;
	sub[1]=NULL;
	reset(true);
	__nodesAllocated++;
}

void Node::reset(bool resetFactors)
{
	totalExitingFlux=Channels(0);
	totalIncidentFlux=Channels(0);
	flags=0;
	// clean subtriangles
	if(!IS_CLUSTER(this) && sub[0])
	{
		sub[0]->reset(resetFactors);
		sub[1]->reset(resetFactors);
	}
	// delete unwanted subtriangle shooters
	if(IS_SUBTRIANGLE(this))
	{
		if(shooter) delete shooter;
		shooter=NULL;
	}
	// reset wanted triangle and cluster shooters
	else
	{
		RR_ASSERT(shooter);
		shooter->reset(resetFactors);
	}
}

Node *Node::brother()
{
	RR_ASSERT(parent);
	return parent->sub[(this==parent->sub[0])?1:0];
}

bool Node::loadEnergyFromSubs()
{
	RR_ASSERT(sub[0]);
	RR_ASSERT(sub[1]);
//        RR_ASSERT(area==0);
//        area=sub[0]->area+sub[1]->area;
//        RR_ASSERT(totalExitingFlux==0);
	totalExitingFlux=sub[0]->totalExitingFlux+sub[1]->totalExitingFlux;
	totalIncidentFlux=sub[0]->totalIncidentFlux+sub[1]->totalIncidentFlux;
	RR_ASSERT(sub[0]->shooter);
	RR_ASSERT(sub[1]->shooter);
	Channels tmp0=sub[0]->shooter->totalExitingFluxToDiffuse/sub[0]->area;
	Channels tmp1=sub[1]->shooter->totalExitingFluxToDiffuse/sub[1]->area;
	Channels e;
	if(sum(tmp0)<sum(tmp1))
	{
		e=tmp0;
		sub[0]->shooter->totalExitingFluxToDiffuse=Channels(0);
		sub[1]->shooter->totalExitingFluxToDiffuse-=e*sub[1]->area;
		RR_ASSERT(sum(sub[1]->shooter->totalExitingFluxToDiffuse)>-0.1);
		clampToZero(sub[1]->shooter->totalExitingFluxToDiffuse); // fix minor numerical errors
	} else {
		e=tmp1;
		sub[0]->shooter->totalExitingFluxToDiffuse-=e*sub[0]->area;
		RR_ASSERT(sum(sub[0]->shooter->totalExitingFluxToDiffuse)>-0.1);
		clampToZero(sub[0]->shooter->totalExitingFluxToDiffuse); // fix minor numerical errors
		sub[1]->shooter->totalExitingFluxToDiffuse=Channels(0);
	}
	RR_ASSERT(shooter);
	shooter->totalExitingFluxToDiffuse+=e*area;
	return e!=Channels(0);
	// v teto fci vznikala nepresnost, min sviticimu synovi s X odebral X+-chyba
	// oprava neeliminuje nepresnost u svitivejsiho syna, pouze zajisti aby min svitivy mel na konci energii 0
}

void Node::propagateEnergyUp()
{
	Node *node=parent;
	while(node && node->loadEnergyFromSubs()) node=node->parent;
}

real Node::accuracy()
{
	RR_ASSERT(shooter);
	return shooter->accuracy();
}

Channels Node::radiosityIndirect() // radiantExitance in W/m^2
{
	Channels e=Channels(0);
	Node *node=parent;
	while(node)
	{
		e+=(node->totalExitingFlux-node->sub[0]->totalExitingFlux-node->sub[1]->totalExitingFlux)/node->area;
		node=node->parent;
	}
	return e;
}

bool Node::check()
{
	RR_ASSERT(!shooter || sum(abs(shooter->totalExitingFluxToDiffuse))<1e10);
	return true;
}

bool Node::contains(Triangle *t)
{
	if(IS_TRIANGLE(this)) return this==t;
	if(IS_SUBTRIANGLE(this)) return false;
	return sub[0]->contains(t) || sub[1]->contains(t);
}

Node::~Node()
{
	RR_ASSERT(!sub[0]);
	RR_ASSERT(!sub[1]);
	if(shooter) delete shooter;
	__nodesAllocated--;
}

//////////////////////////////////////////////////////////////////////////////
//
// subtriangle, part of triangle

unsigned __subtrianglesAllocated=0;

SubTriangle::SubTriangle(SubTriangle *aparent,class Triangle *agrandpa) : Node(aparent,agrandpa)
{
	__subtrianglesAllocated++;
	subvertex=NULL;
	splitVertex_rightLeft=-2;//=dunno, ask somebody else
}

Point3 SubTriangle::to3d(Point2 a)
{
	return grandpa->to3d(a);
}

Point3 SubTriangle::to3d(int vertex)
// returns exact 3d coord where available
{
	RR_ASSERT(vertex>=0 && vertex<=2);
#ifdef IV_POINT
	// ivertex always returns the same 3d
	return ivertex(vertex)->point;
#else
	// subvertex shared by 2 triangles may return slightly different 3d for different triangles
	// may cause blackpixels in render
	return to3d(uv[vertex]);
#endif
}

Point3 SubTriangle::to3dlo(int vertex)
// returns approximate 3d coord (2d transformed to 3d)
{
	RR_ASSERT(vertex>=0 && vertex<=2);
	return to3d(uv[vertex]);
}

Point3 Triangle::to3d(int v)
{
	RR_ASSERT(v>=0 && v<=2);
	return *getVertex(v);
}

real SubTriangle::perimeter()
{
	return size(u2)+size(v2)+size(u2-v2);
}

SubTriangle *SubTriangle::brotherSub()
{
	RR_ASSERT(IS_SUBTRIANGLE(this));
	return SUBTRIANGLE(parent->sub[(this==parent->sub[0])?1:0]);
}

bool SubTriangle::isRight()
{
	bool result=v2==brotherSub()->u2;
	RR_ASSERT(result!=(u2==brotherSub()->v2));
	return result;
}

bool SubTriangle::isRightLeft()
{
	bool result=SUBTRIANGLE(sub[0])->v2==SUBTRIANGLE(sub[1])->u2;
	RR_ASSERT(result!=(SUBTRIANGLE(sub[1])->v2==SUBTRIANGLE(sub[0])->u2));
	return result;
}

#define MAGIC1  1.039618

int SubTriangle::getSplitVertexSlow()
{
	// magicky nasobitel je tu proto aby pri shodne delce stran,
	// ktera nastava casto,
	// nedaval vinou zaokrouhlovacich chyb pokazde jine vysledky.

	#define IS_00(r) (fabs(r)<1)

	// zjisti result a jestli hrozi ze pokazdy vrati jinej vysledek
	bool danger=IS_00(size2(u2)-size2(v2)*MAGIC1);
	int result;
	if(size2(u2)>size2(v2)*MAGIC1)
	{
		danger=danger || IS_00(size2(u2-v2)-size2(u2)*MAGIC1);
		if(size2(u2-v2)>size2(u2)*MAGIC1)
			result=0;
		else
			result=2;
	}
	else
	{
		danger=danger || IS_00(size2(u2-v2)-size2(v2)*MAGIC1);
		if(size2(u2-v2)>size2(v2)*MAGIC1)
			result=0;
		else
			result=1;
	}

	// pokud je neco v cache, pouzije to, ale overi ze se to shoduje
	// a kdyz ne tak bylo opravdu zdetekovano nebezpeci chyby
	if(splitVertex_rightLeft>=0)
	{
		RR_ASSERT(danger || result==splitVertex_rightLeft%3);
		result=splitVertex_rightLeft%3;
	}

	return result;
}

int SubTriangle::getSplitVertex()
{
	RR_ASSERT(this);
	RR_ASSERT(sub[0]);
	RR_ASSERT(sub[1]);
	if(SUBTRIANGLE(sub[0])->uv[0]==uv[0]) return 0;
	if(SUBTRIANGLE(sub[0])->uv[0]==uv[1]) return 1;
	RR_ASSERT(SUBTRIANGLE(sub[0])->uv[0]==uv[2]);
	return 2;
}

void SubTriangle::splitGeometry(IVertex *asubvertex)
{
	RR_ASSERT(this);
	if(sub[0]) return;

	// zjisti splitvertex
	// pokud nam nekdo prikazuje jakej pouzit, fce to vi a rekne nam to
	DBGLINE
	int rot=getSplitVertexSlow();
	DBGLINE

	// split the longest side, calculate splita and splitb
	// split line is { [u,v] | splita*u+splitb*v=1 }
	Point2 point=uv[rot];
	Vec2 splitvector=(uv[(rot+1)%3]+uv[(rot+2)%3])/2-uv[rot];
	real r=point.x*splitvector.y-point.y*splitvector.x;
	if(r>=0 && r<SMALL_REAL) r=SMALL_REAL; else
	if(r<=0 && r>-SMALL_REAL) r=-SMALL_REAL;

	// prikazuje nam nekdo kteryho syna dat doprava/doleva?
	if(splitVertex_rightLeft>=0)
	{
		bool rl=(splitVertex_rightLeft/3)!=0;
		if(rl && r<0)//prikazano rightleft ale r<0
		{
			RR_ASSERT(r>-0.01);
			r=SMALL_REAL;
		}
		else
		if(!rl && r>0)//prikazano leftright ale r>0
		{
			RR_ASSERT(r<0.01);
			r=-SMALL_REAL;
		}
	}
	// pokud nikdo neprikazoval a cache je prazdna, zaplnime ji,
	// orakulum neporadilo tak nevadi kdyz si to rozhodneme sami
	else
	{
		splitVertex_rightLeft=rot+(r>0?3:0);
	}
#ifdef LOG_LOADING_MES
	printf(" rot=%i rl=%i\n",rot,(r>0)?1:-1);
#endif

	DBGLINE
	splita=splitvector.y/r;
	splitb=-splitvector.x/r;
	// create subtriangles
	DBGLINE
	SubTriangle *sa=new SubTriangle(this,grandpa);
	DBGLINE
	sa->uv[0]=uv[rot];
	sa->uv[1]=uv[(rot+1)%3];
	sa->uv[2]=(uv[(rot+1)%3]+uv[(rot+2)%3])/2;
	sa->u2=sa->uv[1]-sa->uv[0];//sidevector1;
	sa->v2=sa->uv[2]-sa->uv[0];//splitvector;
	sa->area=area/2;
	sub[r<0?1:0]=sa;
	SubTriangle *sb=new SubTriangle(this,grandpa);
	sb->uv[0]=uv[rot];
	sb->uv[1]=sa->uv[2];//(uv[(rot+1)%3]+uv[(rot+2)%3])/2;
	sb->uv[2]=uv[(rot+2)%3];
	sb->u2=sb->uv[1]-sb->uv[0];//splitvector;
	sb->v2=sb->uv[2]-sb->uv[0];//sidevector2;
	sb->area=area/2;
	sub[r<0?0:1]=sb;
	// create subvertex
	DBGLINE
	RR_ASSERT(this);
	createSubvertex(asubvertex,rot);
	DBGLINE
}

void SubTriangle::splitHits(Hits* phits,Hits *phits2)
{
	RR_ASSERT(sub[0]);
	RR_ASSERT(phits);
	RR_ASSERT(phits2);
	RR_ASSERT(!phits2->hits);
	unsigned old_hits=phits->hits;
	phits->reset();
	for(unsigned i=0;i<old_hits;i++)
	{
		bool first=phits->hit[i].u*splita+phits->hit[i].v*splitb>1;
		((!first)?phits:phits2)->insertWithSubdivision(phits->hit[i]);
	}
}

bool SubTriangle::wishesToSplitReflector()
{
	RR_ASSERT(shooter);
	if(!sub[0]) return false;//dal uz splitovat nejde
	if(sub[0]->shooter) return false;//uz je splitnutej
	real e0=sum(sub[0]->totalExitingFlux);
	real e1=sum(sub[1]->totalExitingFlux);
	real esum=ABS(e0)+ABS(e1);
	real edif=fabs(e0-e1);
	return edif>esum/REFLECTOR_MESHING;
}

SubTriangle::~SubTriangle()
{
	if(sub[0])
	{
		delete SUBTRIANGLE(sub[0]);
		sub[0]=NULL;
		delete SUBTRIANGLE(sub[1]);
		sub[1]=NULL;
	}
	// pocitam ze subtriangly budou zanikat vzdy vsechny naraz
	// tak nema cenu updatovat ivertexy, vsechny prijdou taky smazat
//#ifdef SUPPORT_INTERPOL
//	for(int i=0;i<3;i++)
//	{
//		IVertex *iv=ivertex(i);
//		if(iv) iv->remove(this,false);
//	}
//#endif
	__subtrianglesAllocated--;
}


//////////////////////////////////////////////////////////////////////////////
//
// triangle, part of cluster and object

unsigned __trianglesAllocated=0;
unsigned __trianglesWithBadNormal=0;

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4355)
#endif
Triangle::Triangle() : SubTriangle(NULL,this)
#ifdef _MSC_VER
#pragma warning(pop)
#endif
{
	__trianglesAllocated++;
	topivertex[0]=NULL;
	topivertex[1]=NULL;
	topivertex[2]=NULL;
	edge[0]=NULL;
	edge[1]=NULL;
	edge[2]=NULL;
	area=0;       // says that setGeometry wasn't called yet
	surface=NULL; // says that setSurface wasn't called yet
}

static real minAngle(real a,real b,real c) // delky stran
{
	real angleA = fast_acos((b*b+c*c-a*a)/(2*b*c));
	real angleB = fast_acos((a*a+c*c-b*b)/(2*a*c));
	real angleC = fast_acos((a*a+b*b-c*c)/(2*a*b));
	return MIN(MIN(angleA,angleB),angleC);
}

// calculates triangle area from triangle vertices
real calculateArea(Vec3 v0, Vec3 v1, Vec3 v2)
{
	real a=size2(v1-v0);
	real b=size2(v2-v0);
	real c=size2(v2-v1);
	return sqrt(2*b*c+2*c*a+2*a*b-a*a-b*b-c*c)/4;
}

// rots muze prikazat kolikrat zarotovat, -1=autodetekce
// vraci kolikrat zarotoval, -1..-11=vadna geometrie, zahodit
// n=NULL .. spocita normalu sam
// n!=NULL .. pouzije zadanou normalu
//
// Objekt muze byt scalovany. a/b/c ale dostavame v objectspace a tak musi zustat.
// Pokud ale nevyscalujeme area, bude pri distribuci vznikat/zanikat energie.
// obj2world tedy pouzijeme pouze k vypoctu area ve worldspace.

S8 Triangle::setGeometry(Vec3* a,Vec3* b,Vec3* c,const RRMatrix3x4 *obj2world,Normal *n,float ignoreSmallerAngle,float ignoreSmallerArea)
{
	isValid=0;
	qvertex[0]=a;
	qvertex[1]=b;
	qvertex[2]=c;

	// set u3,v3,n3
	qn3=normalized(ortogonalTo(getR3(),getL3()));
	qn3.w=-dot(getS3(),getN3());
	if(!IS_VEC3(getN3())) return -3; // throw out degenerated triangle
	qu3=normalized(getR3());
	qv3=ortogonalTo(getN3(),getU3());
	if(!IS_VEC3(getV3())) return -10; // throw out degenerated triangle

	// set s2,u2,v2
	real rsize=size(getR3());
	real lsize=size(getL3());
	if(rsize<=0 || lsize<=0) return -1; // throw out degenerated triangle
	real psqr=size2(getU3()-(getL3()/lsize));// ctverec nad preponou pri jednotkovejch stranach
	#ifdef ALLOW_DEGENS
	if(psqr<=0) {psqr=0.0001f;LIMITED_TIMES(5,RRReporter::report(WARN,"Low numerical quality, fixing area=0 triangle.\n"));} else
	if(psqr>=4) {psqr=3.9999f;LIMITED_TIMES(5,RRReporter::report(WARN,"Low numerical quality, fixing area=0 triangle.\n"));}
	#endif
	real cosa=1-psqr/2;
	real sina=sqrt(psqr*(1-psqr/4));//sin(fast_acos(cosa)); //first is probably faster
	uv[0]=Vec2(0,0);
	uv[1]=u2=Vec2(rsize,0);
	uv[2]=v2=Vec2(cosa,sina)*lsize;
	area=sina/2*rsize*lsize;
	if(psqr<=0) return -7;
	if(psqr>=4) return -9;
	if(1-psqr/4<=0) return -8;
	if(sina<=0) return -6;
	if(area<=0) return -4;
	if(area<=ignoreSmallerArea) return -5;
	//RR_ASSERT(size(SubTriangle::to3d(2)-*vertex[2])<0.001);
	RR_ASSERT(u2.x>=0);
	RR_ASSERT(u2.y==0);
	RR_ASSERT(v2.y>=0);

	// premerit min angle v localspace (mohlo by byt i ve world)
	real minangle = minAngle(lsize,rsize,size(getL3()-getR3()));
	if(!IS_NUMBER(area)) return -13;
	if(minangle<=ignoreSmallerAngle) return -14;

	// premerit area v worldspace
	if(obj2world)
		area = calculateArea(obj2world->transformedPosition(*a),obj2world->transformedPosition(*b),obj2world->transformedPosition(*c));
	else
		area = calculateArea(*a,*b,*c);
	if(!IS_NUMBER(area)) return -11;
	if(area<=ignoreSmallerArea) return -12;

	RR_ASSERT(IS_VEC3(getV3()));
	isValid=1;
	return 0;
}

// resetPropagation = true
//  nastavi skoro vse na vychozi hodnoty zacatku vypoctu -> pouze primaries maji energie, jinde jsou nuly
//  u nekterych promennych predpoklada ze uz jsou vynulovane
// resetPropagation = false
//  spoleha na to ze promenne uz jsou naplnene probihajicim vypoctem
//  pouze zaktualizuje primary illum energie podle surfacu a additionalExitingFlux
// return new primary exiting radiant flux in watts

Channels Triangle::setSurface(const RRMaterial *s, const Vec3& _sourceIrradiance, bool resetPropagation)
{
	RR_ASSERT(area!=0);//setGeometry must be called before setSurface
	RR_ASSERT(s);

	// aby to necrashlo kdyz uzivatel neopravnene zada NULL
	static RRMaterial emergencyMaterial;
	static bool emergencyInited = false;
	if(!emergencyInited)
	{
		emergencyInited = true;
		emergencyMaterial.reset(false);
	}
	if(!s) s = &emergencyMaterial;

	surface=s;
#if CHANNELS == 1
	#error CHANNELS == 1 not supported here.
#else
	Channels newSourceIrradiance = _sourceIrradiance;
	Channels newSourceExitance = surface->diffuseEmittance + _sourceIrradiance * surface->diffuseReflectance;
	Channels newSourceIncidentFlux = newSourceIrradiance * area;
	Channels newSourceExitingFlux = newSourceExitance * area;
#endif
	RR_ASSERT(surface->diffuseEmittance[0]>=0); // teoreticky by melo jit i se zapornou
	RR_ASSERT(surface->diffuseEmittance[1]>=0);
	RR_ASSERT(surface->diffuseEmittance[2]>=0);
	RR_ASSERT(area>=0);
	RR_ASSERT(_sourceIrradiance.x>=0); // teoreticky by melo jit i se zapornou
	RR_ASSERT(_sourceIrradiance.y>=0);
	RR_ASSERT(_sourceIrradiance.z>=0);
	// load triangle shooter with energy emited by surface
	RR_ASSERT(shooter);
	// set this primary illum
	if(resetPropagation)
	{
		// set primary illum
		shooter->totalExitingFluxToDiffuse = newSourceExitingFlux;
		// load received energy accumulator
		totalExitingFlux = newSourceExitingFlux;
		totalIncidentFlux = newSourceIncidentFlux;
	}
	else
	{
		Channels oldSourceExitingFlux = getDirectExitingFlux();
		Channels addSourceExitingFlux = newSourceExitingFlux-oldSourceExitingFlux;
		Channels oldSourceIncidentFlux = getDirectIncidentFlux();
		Channels addSourceIncidentFlux = newSourceIncidentFlux-oldSourceIncidentFlux;
		// add primary illum
		shooter->totalExitingFluxToDiffuse += addSourceExitingFlux;
		// load received energy accumulator
		totalExitingFlux += addSourceExitingFlux;
		totalIncidentFlux += addSourceIncidentFlux;
	}
	sourceIncidentFlux = newSourceIncidentFlux;
	return newSourceExitingFlux;
}

Point3 Triangle::to3d(Point2 a)
{
	return getS3()+getU3()*a.x+getV3()*a.y;
}

void Triangle::compact()
{
	hits.compact();
}

Triangle::~Triangle()
{
	// iv_forEach()
	// ze vsech ivertexu v trianglu ostranit trianglovy cornery
	// prazdny ivertexy odstranit
	// subtriangly zrusit...
	__trianglesAllocated--;
}

//////////////////////////////////////////////////////////////////////////////
//
// reflectors (light sources and things that reflect light)

Reflectors::Reflectors()
{
	nodesAllocated=0;
	node=NULL;
	nodes=0;
	reset();
}

void Reflectors::reset()
{
	//for(int i=nodes;i--;) remove(i);
	for(int i=nodes;i--;) node[i]->flags&=~FLAG_IS_REFLECTOR; // optimized version
	nodes=0;
	bests=0;
	refreshing=1;
}

void Reflectors::resetBest()
{
	bests=0;
	refreshing=1;
}

bool Reflectors::insert(Node *anode)
{
	if(anode->flags&FLAG_IS_REFLECTOR) return false;
	if(anode->shooter->totalExitingFluxDiffused==Channels(0) && anode->shooter->totalExitingFluxToDiffuse==Channels(0)) return false;
	if(!nodesAllocated)
	{
		nodesAllocated=1024;
		node=(Node **)malloc(nodesAllocated*sizeof(Node *));
	}
	else
	if(nodes==nodesAllocated)
	{
		size_t oldsize=nodesAllocated*sizeof(Node *);
		nodesAllocated*=4;
		node=(Node **)realloc(node,oldsize,nodesAllocated*sizeof(Node *));
	}
	anode->flags|=FLAG_IS_REFLECTOR;
	node[nodes++]=anode;
	return true;
}

void Reflectors::remove(unsigned n)
{
	RR_ASSERT(node[n]->flags&FLAG_IS_REFLECTOR);
	node[n]->flags&=~FLAG_IS_REFLECTOR;
	node[n]=node[--nodes];
	bests=0; // invalidate best cache
}

void Reflectors::insertObject(Object *o)
{
	for(unsigned i=0;i<o->triangles;i++) insert(&o->triangle[i]);
}

void Reflectors::removeSubtriangles()
{
	for(int i=nodes;i--;)
		if(IS_SUBTRIANGLE(node[i])) remove(i);
}

bool Reflectors::check()
{
	return true;
}
/*
best() - vraci nejlepsi node pro dalsi zpracovani (distrib nebo refresh)

Stary system a proc v nem nefunguje reset se zachovanim faktoru
---------------------------------------------------------------
Kdyz se posune lampa a resetne vse krome faktoru, 
zustane velka accuracy
nasledujici refreshe jsou vsechny strasne drahe
a protoze po pohybu lampy mohou cekat stovky akutnich refreshu aby se obraz dostal z nejhorsiho, muze to trvat i minutu.
Navic i veci ktere by stacilo pro zacatek jen distribnout se refreshuji.
Mely by se nejdriv udelat akutni distriby
a pak zacit refreshovat jako pri nizke accuracy a postupne ji zvysovat.
Best bude zpocatku vybirat nody s nizkou accuracy a zajisti rychle dostani se z nejhorsiho.
Po case ale nepujde vybrat nic k refreshi,
je nutne to zdetekovat a umele zvysit accuracy.

Novy system, navrh 1
--------------------
(Scene) Accuracy bude nezavisla na mnozstvi nastrilenych fotonu.
Po resetu se zachovanim faktoru se vynuluje.
Je nutny kvalitni regulator aby se po posunu lampy bez resetu faktoru zaclo 99% distribuci
a postupne preslo na 99% refreshe.
Podle ceho regulovat?

Novy system, navrh 2
--------------------
(Scene) Accuracy zustane zavisla na mnozstvi nastrilenych fotonu.
Po resetu se zachovanim faktoru se nezmeni.
Nebude ale dovolene refreshnout na vic jak 4nasobek i kdyby to podle accuracy vypadalo rozumne.
Tim se zajisti ze se nezastavi v tune drahych refreshu.
Jak ale zajistit ze provede rychle sadu distribu?

Optimalizace
Kdyz mam jednoho ktery chce refreshnout z 0 na 10000 a ostatni jsou proti nemu nedulezity,
dovolit i vetsi skok nez na 4x.

Novy system, navrh 3 YES
--------------------
Prestat pouzivat scene accuracy.
Nechat ji jen pro statistiky a pridat do statistik i min/max facove accuracy.

Pri resetu se zachovanim faktoru vynulovat bestarray.

Distribuovat vzdy okamzite kdyz to pohne s aspon 0.001 energie ve scene.
Cislo 0.001 pro jistotu nechat nastavitelne zvenci, v supernasekane scene by mohlo byt moc velke.
(Jak implementovat: kdyz best najde neco pro distrib, zahodit vse pro refresh)

Vsechny ostatni posoudit pro refresh.
Vse s accuracy vic jak 2x vetsi nez best[0] zahodit, at jsou vsichni pro refresh stejny chudaci.
To co zustalo refreshnout na 2x. (2x nechat zvenci volitelny)

Jak radit kandidaty na refresh?
Podle jejich accuracy, cim mensi, tim lepsi kandidat.

Zrusit omezene regulujici hacky vykryvajici kolapsy stareho systemu.

Dotazy a odpovedi
-----------------
Q:
Co takhle jit s kazdym refreshem na 2x fotonu (proti minulemu refreshi tehoz facu),
nastrilet jen polovinu a zprumerovat s minulym faktorem?
A:
Pravdepodobne problem pri zaplych subtrianglech nebo clusterech.

*/

Node *Reflectors::best(real allEnergyInScene, real subdivisionSpeed)
{
	DBGLINE
	STATISTIC_INC(numCallsBest);
	// if cache empty, fill cache
	if(!bests && nodes)
	{
		// start accumulating nodes for refresh
		refreshing=1;
restart:
		// search reflector with low accuracy, high totalExitingFluxToDiffuse etc
		real bestQ[BESTS];
		for(unsigned i=0;i<nodes;i++) if(node[i]->shooter)
		{
			// calculate q for node
			real q;
			real toDiffuse=sum(abs(node[i]->shooter->totalExitingFluxToDiffuse));
			// distributor found -> switch from accumulating refreshers to accumulating distributors
			if(refreshing && node[i]->shooter->factors() && toDiffuse>DISTRIB_LEVEL_HIGH*allEnergyInScene)
			{
				refreshing=0;
				bests=0;
				goto restart;
			}
			// calculate quality of distributor
			if(!refreshing)
			{
				if(!node[i]->shooter->factors()) continue;
				if(toDiffuse<DISTRIB_LEVEL_LOW*abs(allEnergyInScene)) continue;
				q=toDiffuse;
			}
			else
			// calculate quality of refresher
			{
				//q=-node[i]->accuracy();
				q=sum(abs(node[i]->shooter->totalExitingFluxDiffused+node[i]->shooter->totalExitingFluxToDiffuse))/(node[i]->shooter->shotsForFactors+0.5f);
			}

			// sort [q,node] into best cache, bestQ[0] is highest
			unsigned pos=bests;
			while(pos>0 && bestQ[pos-1]<q)
			{
				if(pos<BESTS)
				{
					bestNode[pos]=bestNode[pos-1];
					bestQ[pos]=bestQ[pos-1];
				}
				pos--;
			}
			if(pos<BESTS)
			{
				bestNode[pos]=node[i];
				bestQ[pos]=q;
				if(bests<BESTS) bests++;
			}
		}

		// throw out nodes too good for refreshing
		// 1.6% faster when deleted, but danger of infinitely unbalanced refreshing
		if(refreshing)
		{
			while(bests && bestQ[bests-1]*REFRESH_MULTIPLY*MAX_REFRESH_DISBALANCE<bestQ[0]) bests--;
		}

		//printf(refreshing?"*%d ":">%d ",bests);
	}
	// get best from cache
	if(!bests) return NULL;
	Node *best=bestNode[0];
	bests--;
	for(unsigned i=0;i<bests;i++) bestNode[i]=bestNode[i+1];
	RR_ASSERT(best);
	// possibly split best
	if(subdivisionSpeed) // no subdivision -> no splitting
	if(!IS_CLUSTER(best) && SUBTRIANGLE(best)->wishesToSplitReflector())
	{
		RR_ASSERT(!best->sub[0]->shooter);
		RR_ASSERT(!best->sub[1]->shooter);
		best->sub[0]->shooter=new Shooter();
		best->sub[1]->shooter=new Shooter();
		insert(best->sub[0]);
		insert(best->sub[1]);
	}
	return best;
}

struct NodeQ 
{
	Node* node; 
	real q;
};

int CompareNodeQ(const void* elem1, const void* elem2)
{
	return (((NodeQ*)elem2)->q < ((NodeQ*)elem1)->q) ? -1 : 1;
}

bool Reflectors::findFactorsTo(Node *n)
{
	for(unsigned i=0;i<nodes;i++)
	{
		RR_ASSERT(node[i]->shooter);
		real pwr=node[i]->shooter->contains(n);
		if(pwr!=-1)
			printf("[%x %f]",(unsigned)(intptr_t)node[i],pwr);
	}
	printf(" ");
	return false;
}

Reflectors::~Reflectors()
{
	if(node) free(node);
}

//////////////////////////////////////////////////////////////////////////////
//
// set of triangles

Triangles::Triangles()
{
	trianglesAllocated=8;
	triangle=(Triangle **)malloc(trianglesAllocated*sizeof(Triangle *));
	reset();
}

void Triangles::reset()
{
	triangles=0;
	trianglesAfterResurrection=0;//pro jistotu
}

void Triangles::insert(Triangle *key)
{
	if(triangles==trianglesAllocated)
	{
		size_t oldsize=trianglesAllocated*sizeof(Triangle *);
		trianglesAllocated*=2;
		triangle=(Triangle **)realloc(triangle,oldsize,trianglesAllocated*sizeof(Triangle *));
	}
	triangle[triangles++]=key;
}

//removes triangle from set

Triangle *Triangles::get()
{
	if(!triangles) return NULL;
//        if(!trianglesAfterResurrection) trianglesAfterResurrection=triangles;
	triangles--;
	return triangle[triangles];
}

// doesn't remove triangle from set

Triangle *Triangles::get(real a)
{
	RR_ASSERT(triangles>0);
	unsigned t=0;
	while(a>triangle[t]->area)
	{
		a-=triangle[t]->area;
		t++;
		RR_ASSERT(t<triangles);
	}
	return triangle[t];
}

void Triangles::forEach(void (*func)(Triangle *key,va_list ap),...)
{
	va_list ap;
	va_start(ap,func);
	for(unsigned i=0;i<triangles;i++) func(triangle[i],ap);
	va_end(ap);
}

void Triangles::holdAmulet()
{
	trianglesAfterResurrection=triangles;
}

void Triangles::resurrect()
{
	triangles=trianglesAfterResurrection;
	trianglesAfterResurrection=0;
}

Triangles::~Triangles()
{
	free(triangle);
}

//////////////////////////////////////////////////////////////////////////////
//
// set of edges

unsigned __edgesAllocated=0;

Edges::Edges()
{
	edgesAllocated=4;
	edge=(Edge **)malloc(edgesAllocated*sizeof(Edge *));
	reset();
	__edgesAllocated+=edgesAllocated;
}

void Edges::reset()
{
	edges=0;
}

void Edges::insert(Edge *key)
{
	if(edges==edgesAllocated)
	{
		__edgesAllocated+=7*edgesAllocated;
		size_t oldsize=edgesAllocated*sizeof(Edge *);
		edgesAllocated*=8;
		edge=(Edge **)realloc(edge,oldsize,edgesAllocated*sizeof(Edge *));
	}
	edge[edges++]=key;
}

Edge *Edges::get()
{
	RR_ASSERT(edges>0);
	edges--;
	return edge[edges];
}

Edges::~Edges()
{
	if(edgesAllocated) free(edge);
	__edgesAllocated-=edgesAllocated;
}

//////////////////////////////////////////////////////////////////////////////
//
// object, part of scene

Object::Object(int avertices,int atriangles)
{
	vertices=avertices;
	triangles=atriangles;
	edges=0;
	vertex=new Vec3[vertices];
	triangle=new Triangle[triangles];
	edge=NULL;
	objSourceExitingFlux=Channels(0);
	for(unsigned t=0;t<triangles;t++) triangle[t].object=this;
	//vertexIVertex=new IVertex*[vertices];
	//memset(vertexIVertex,0,sizeof(void*)*vertices);
	IVertexPool=NULL;
	IVertexPoolItems=0;
	IVertexPoolItemsUsed=0;
	subdivisionSpeed = 0;
}

unsigned Object::getTriangleIndex(Triangle* t)
{
	unsigned idx = (unsigned)(t-triangle);
	return (idx<triangles)?idx:UINT_MAX;
}

void addEdgeWith(Triangle *t1,va_list ap)
{
	Triangle *t2      =va_arg(ap,Triangle *);
	Edge     *edge    =va_arg(ap,Edge *);
	unsigned *edges   =va_arg(ap,unsigned *);
	unsigned maxedges =va_arg(ap,unsigned);
	float    maxSmoothAngle =*va_arg(ap,float*);

	for(unsigned v1=0;v1<3;v1++)
	  if(!t1->edge[v1])
	    for(unsigned v2=0;v2<3;v2++)
	      if(!t2->edge[v2] &&
	         t1->getVertex(v1)==t2->getVertex((v2+1)%3) &&
	         t1->getVertex((v1+1)%3)==t2->getVertex(v2))
	{
		Angle angle=angleBetweenNormalized(t1->getN3(),t2->getN3());
		if(angle<MAX_INTERPOL_ANGLE)
		{
		  RR_ASSERT(*edges<maxedges);
		  if(*edges>=maxedges)
		  {
		    printf("# More edges than expected, throwing out.\n");
		    return;
		  }
		  edge[*edges].angle=angle;
		  edge[*edges].interpol=INTERPOL_BETWEEN_A(t1,t2,angle);
		  edge[*edges].vertex[0]=t1->getVertex(v1);
		  edge[*edges].vertex[1]=t1->getVertex((v1+1)%3);
		  edge[*edges].triangle[0]=t1;
		  edge[*edges].triangle[1]=t2;
		  RR_ASSERT(!t1->edge[v1]); //!!! nastava pri degenerovanych trianglech, je to neskodne?
		  RR_ASSERT(!t2->edge[v2]);
		  t1->edge[v1]=&edge[*edges];
		  t2->edge[v2]=&edge[*edges];
		  (*edges)++;
		}
	}
}

void Object::buildEdges(float maxSmoothAngle)
// triangles with surface=NULL get intentionally no edges
// if they get edges, createSubvertex would go 
//  from triangle with surface+topIVertices via edge to triangle without surface+topIVertices
//  and operate with NULL topIVertex -> crash
{
	RR_ASSERT(!edge);

	edge=new Edge[triangles*3/2];
	for(unsigned t=0;t<triangles;t++)
	{
		triangle[t].edge[0]=NULL;
		triangle[t].edge[1]=NULL;
		triangle[t].edge[2]=NULL;
	}
	Triangles *trianglesInV=new Triangles[vertices];
	RRMesh* meshImporter = importer->getCollider()->getMesh();
	for(unsigned t=0;t<triangles;t++)
		if(triangle[t].surface)
			for(int v1=0;v1<3;v1++)
			{
				RRMesh::Triangle ve;
				meshImporter->getTriangle(t,ve);
				unsigned v = ve[v1];
				RR_ASSERT(v>=0 && v<vertices); //v musi byt vertexem tohoto objektu
				trianglesInV[v].insert(&triangle[t]);
			}
	for(unsigned v=0;v<vertices;v++)
	{
		Triangle *tri;
		while((tri=trianglesInV[v].get()))
		{
			trianglesInV[v].forEach(addEdgeWith,tri,edge,&edges,(unsigned)(triangles*3/2),&maxSmoothAngle);
		}
	}
	delete[] trianglesInV;
}

Object::~Object()
{
	check();
	delete[] triangle;
	delete[] vertex;
	if(edge) delete[] edge;
	//delete[] vertexIVertex;
	deleteIVertices();
}

// resetPropagation = true
//  uvede energie v objektu do stavu po nacteni sceny
//  akceptuje upravene surfacy
// resetPropagation = false
//  trianglum zaktualizuje vychozi energie
//  akceptuje upravene surfacy
//  nesaha na subtriangly, coz je asi v poradku
//  nesaha na clustery, coz muze byt chyba //!!! opravit pokud nekdy budu pouzivat clustery

void Object::resetStaticIllumination(bool resetFactors, bool resetPropagation)
{
	// nastavi akumulatory na pocatecni hodnoty
	// separated to three floats because of openmp
	//objSourceExitingFlux=Channels(0);
	RRReal tmpx = 0;
	RRReal tmpy = 0;
	RRReal tmpz = 0;
	bool propagateUp = resetPropagation && subdivisionSpeed; // no subdivision -> propagateEnergyUp is no op
#pragma omp parallel for schedule(static,1) reduction(+:tmpx,tmpy,tmpz) // fastest: indifferent
	for(int t=0;(unsigned)t<triangles;t++) if(triangle[t].surface) 
	{
		// smaze akumulatory (ale necha jim flag zda jsou v reflectors)
		if(resetPropagation)
		{
			U8 flag=triangle[t].flags&FLAG_IS_REFLECTOR;triangle[t].reset(resetFactors);triangle[t].flags=flag;
		}

		// nastavi akumulatory na pocatecni hodnoty
		Vec3 additionalIrradiance;
		importer->getTriangleIllumination(t,RM_IRRADIANCE_PHYSICAL,additionalIrradiance);
		Channels tmp = abs(triangle[t].setSurface(triangle[t].surface,additionalIrradiance,resetPropagation));
		//objSourceExitingFlux += tmp;
		tmpx += tmp.x;
		tmpy += tmp.y;
		tmpz += tmp.z;

		if(propagateUp)
		{
			if(triangle[t].surface) triangle[t].propagateEnergyUp();
		}
	}
	objSourceExitingFlux = Channels(tmpx,tmpy,tmpz);
}

bool Object::contains(Triangle *t)
{
	return (t>=&triangle[0]) && (t<&triangle[triangles]);
}

bool Object::contains(Node *n)
{
	return 
		(IS_TRIANGLE(n) && contains(TRIANGLE(n))) ||
		(IS_SUBTRIANGLE(n) && contains(n->grandpa));
}

bool Object::check()
{
	return true;
}


//////////////////////////////////////////////////////////////////////////////
//
// scene

Scene::Scene()
{
	object=NULL;
	phase=0;
	improvingStatic=NULL;
	shotsForNewFactors=0;
	shotsAccumulated=0;
	shotsForFactorsTotal=0;
	shotsTotal=0;
	staticSourceExitingFlux=Channels(0);
	sceneLevelHits = new LevelHits();
	sceneRay = RRRay::create();
	sceneRay->rayFlags = RRRay::FILL_DISTANCE|RRRay::FILL_SIDE|RRRay::FILL_POINT2D|RRRay::FILL_TRIANGLE;
	sceneRay->rayLengthMin = SHOT_OFFSET; // offset 0.1mm resi situaci kdy jsou 2 facy ve stejne poloze, jen obracene zady k sobe. bez offsetu se vzajemne zasahuji.
	sceneRay->rayLengthMax = BIG_REAL;
	sceneRay->collisionHandler = &skipTriangle;
}

Scene::~Scene()
{
	abortStaticImprovement();
	delete object;
	delete sceneLevelHits;
	delete sceneRay;
}

void Scene::objInsertStatic(Object *o)
{
	RR_ASSERT(!object);
	object = o;
	staticReflectors.insertObject(o);
	staticSourceExitingFlux+=o->objSourceExitingFlux;
}

RRStaticSolver::Improvement Scene::resetStaticIllumination(bool resetFactors, bool resetPropagation)
{
	if(resetFactors)
		resetPropagation = true;

	// probihajici vypocet faktoru nebo probihajici distribuce
	// teoreticky muze bezet dal pokud neresetuji propagaci,
	// ale zmeny v primaries je nutne zacit zpracovavat hned, takze v kazdem pripade abort.
	abortStaticImprovement();

	if(resetFactors)
	{
		shotsForFactorsTotal=0;
		shotsTotal=0;
	}
	staticSourceExitingFlux=Channels(0);

/*	
proc rusit nejdriv jen suby a pak vsechny? nestaci zrusit vsechny?
	// subtriangly vznikle behem predchoziho vypoctu zrusim, abych setril pamet a pomohl bidne interpolaci.
	// pokud ale vypocet nerusim a dal propaguji, necham si je.
	if(resetPropagation)
	{
		staticReflectors.removeSubtriangles();
	}
*/
	// pokud rusim probihajici propagaci, reflektory zanikaji, pozdeji si vyrobim nove z primaries.
	// pokud nerusim probihajici propagaci, reflektory musi byt dal evidovane. je ale nutne resetnout predpocitany best()
	if(resetPropagation)
	{
		staticReflectors.reset();
	}
	else
	{
		staticReflectors.resetBest();
	}

	object->resetStaticIllumination(resetFactors,resetPropagation);

	// pokud jsem smazal stare reflektory, vlozim nove.
	// pokud jsem stare zachoval, vlozim nove. vlozeni jiz vlozeneho nevadi, to je ohlidane.
	staticReflectors.insertObject(object);

	staticSourceExitingFlux+=object->objSourceExitingFlux;

	return (staticSourceExitingFlux!=Channels(0)) ? RRStaticSolver::NOT_IMPROVED : RRStaticSolver::FINISHED;
}

//////////////////////////////////////////////////////////////////////////////
//
// trace ray, reflect from triangles and mark hitpoints
// return amount of power added to scene

Vec3 refract(Vec3 N,Vec3 I,real r)
{
	real ndoti=dot(N,I);
	if(ndoti<0) r=1/r;
	real D2=1-r*r*(1-ndoti*ndoti);
	if(D2>=0)
	{
		real a;
		if(ndoti>=0) a=r*ndoti-sqrt(D2);
		else a=r*ndoti+sqrt(D2);
		return N*a-I*r;
	} else {
		// total internal reflection
		return N*(2*ndoti)-I;
	}
}

#define CHECK_HEAP //delete new char

unsigned __shot=0;

#define LOG_RAY(aeye,adir,adist,hit) { \
	STATISTIC( \
	RRStaticSolver::getSceneStatistics()->lineSegments[RRStaticSolver::getSceneStatistics()->numLineSegments].point[0]=aeye; \
	RRStaticSolver::getSceneStatistics()->lineSegments[RRStaticSolver::getSceneStatistics()->numLineSegments].point[1]=(aeye)+(adir)*(adist); \
	RRStaticSolver::getSceneStatistics()->lineSegments[RRStaticSolver::getSceneStatistics()->numLineSegments].infinite=!hit; \
	++RRStaticSolver::getSceneStatistics()->numLineSegments%=RRStaticSolver::getSceneStatistics()->MAX_LINES; ) }

// vraci:
//  celkove mnozstvi z difusnich povrchu ODRAZENE power (power*T1.diffuseReflectance + power*T1.specularReflectance*T2.diffuseReflectance + atd)
//  s korektnimi materialy by to nikdy nemelo prekrocit vstupni power
// vedlejsi efekty:
//  do hitTriangle->hits.insert() nalozi celkove mnozstvi difusnimi povrchy PRIJATE power (power+ power*T1.specularReflectance + atd)
//  i s korektnimi materialy muze prekrocit vstupni power
//  obvykle jdou jednotlive kousky do ruznych trianglu, takze do jednoho trianglu se neinsertne vic nez power,
//   ale nekdy se foton od leskleho povrchu odrazi zpet a do jednoho trianglu se muze naakumulovat vic nez power
//   to neni chyba, velka je pouze irradiance, exitance (po vynasobeni diffuseReflectance) bude opet mala
HitChannels Scene::rayTracePhoton(Point3 eye,Vec3 direction,Triangle *skip,HitChannels power)
// returns power which will be diffuse reflected (result<=power)
// side effects: inserts hits to diffuse surfaces
{
	RR_ASSERT(IS_VEC3(eye));
	RR_ASSERT(IS_VEC3(direction));
	RR_ASSERT(fabs(size2(direction)-1)<0.001);//ocekava normalizovanej dir
	RRRay& ray = *sceneRay;
	ray.rayOrigin = eye;
	ray.rayDirInv[0] = 1/direction[0];
	ray.rayDirInv[1] = 1/direction[1];
	ray.rayDirInv[2] = 1/direction[2];
	skipTriangle.skip = (unsigned)(skip-object->triangle);
	Triangle* hitTriangle = (object->triangles // although we may dislike it, somebody may feed objects with no faces which confuses intersect_bsp
		&& object->importer->getCollider()->intersect(&ray)) ? &object->triangle[ray.hitTriangle] : NULL;
	__shot++;
	//LOG_RAY(eye,direction,hitTriangle?ray.hitDistance:0.2f,hitTriangle);
	if(!hitTriangle || !hitTriangle->surface) // !hitTriangle is common, !hitTriangle->surface is error (bsp se generuje z meshe a surfacu(null=zahodit face), bsp hash se generuje jen z meshe. -> po zmene materialu nacte stary bsp a zasahne triangl ktery mel surface ok ale nyni ma NULL)
	{
		// ray left scene and vanished
		return HitChannels(0);
	}
	RR_ASSERT(hitTriangle->u2.y==0);
	RR_ASSERT(IS_NUMBER(ray.hitDistance));
	static unsigned s_depth = 0;
	if(s_depth>25) 
	{
		STATISTIC_INC(numDepthOverflows);
		return HitChannels(0);
	}
	s_depth++;
	if(ray.hitFrontSide) STATISTIC_INC(numRayTracePhotonFrontHits); else STATISTIC_INC(numRayTracePhotonBackHits);
	// otherwise surface with these properties was hit
	RRSideBits side=hitTriangle->surface->sideBits[ray.hitFrontSide?0:1];
	RR_ASSERT(side.catchFrom); // check that bad side was not hit
	// calculate power of diffuse surface hits
	HitChannels  hitPower=HitChannels(0);
	// stats
	//if(!side.receiveFrom) RRStaticSolver::getSceneStatistics()->numRayTracePhotonHitsNotReceived++;
	//RRStaticSolver::getSceneStatistics()->sumRayTracePhotonHitPower+=power;
	//RRStaticSolver::getSceneStatistics()->sumRayTracePhotonDifRefl+=hitTriangle->surface->diffuseReflectance;
	// diffuse reflection
	// no real reflection is done here, but energy is stored for further
	//  redistribution along existing or newly calculated form factors
	// hits with power below 1% are ignored to save a bit of time
	//  without visible loss of quality
	if(side.receiveFrom)
	if(sum(abs(hitTriangle->surface->diffuseReflectance*power))>0.01)
	{
		STATISTIC_INC(numRayTracePhotonHitsReceived);
		hitPower+=sum(abs(hitTriangle->surface->diffuseReflectance*power));
		if(object->subdivisionSpeed)
		{
			// expensive storage with u/v/power for each hit -> subdivision is possible
			Hit hitPoint2d;
			// prepocet u,v ze souradnic (rightside,leftside)
			//  do *hitPoint2d s ortonormalni bazi (u3,v3)
			hitPoint2d.u=ray.hitPoint2d[0]*hitTriangle->u2.x+ray.hitPoint2d[1]*hitTriangle->v2.x;
			hitPoint2d.v=ray.hitPoint2d[1]*hitTriangle->v2.y;
			hitPoint2d.setPower(power);
			// put triangle among other hit triangles
			if(!hitTriangle->hits.hits) hitTriangles.insert(hitTriangle);
			// inform subtriangle where and how powerfully it was hit
			hitTriangle->hits.insertWithSubdivision(hitPoint2d);
		}
		else
		{
			// cheap storage with accumulated power -> subdivision is not possible
			// put triangle among other hit triangles
			if(!hitTriangle->hits.hits) hitTriangles.insert(hitTriangle);
			// inform subtriangle where and how powerfully it was hit
			hitTriangle->hits.insertWithoutSubdivision(power);
		}
	}
	// mirror reflection
	// speedup: weaker rays continue less often but with
	//  proportionally increased power
	if(side.reflect)
	if(fabs(power*hitTriangle->surface->specularReflectance)>0.1)
//	if(sqrt(power*material->specularReflectance)*rand()<RAND_MAX)
	{
		STATISTIC_INC(numRayTracePhotonHitsReflected);
		// calculate hitpoint
		Point3 hitPoint3d=eye+direction*ray.hitDistance;
		// calculate new direction after ideal mirror reflection
		Vec3 newDirection=hitTriangle->getN3()*(-2*dot(direction,hitTriangle->getN3())/size2(hitTriangle->getN3()))+direction;
		// recursively call this function
		hitPower+=rayTracePhoton(hitPoint3d,newDirection,hitTriangle,/*sqrt*/(power*hitTriangle->surface->specularReflectance));
	}
	// getting through
	// speedup: weaker rays continue less often but with
	//  proportionally increased power
	if(side.transmitFrom)
	if(fabs(power*hitTriangle->surface->specularTransmittance.sum())>0.3f)
//	if(sqrt(power*material->specularTransmittance)*rand()<RAND_MAX)
	{
		STATISTIC_INC(numRayTracePhotonHitsTransmitted);
		// calculate hitpoint
		Point3 hitPoint3d=eye+direction*ray.hitDistance;
		// calculate new direction after refraction
		Vec3 newDirection=-refract(hitTriangle->getN3(),direction,hitTriangle->surface->refractionIndex);
		// recursively call this function
		hitPower+=rayTracePhoton(hitPoint3d,newDirection,hitTriangle,/*sqrt*/(power*hitTriangle->surface->specularTransmittance.avg()));
	}
	s_depth--;
	return hitPower;
}

//////////////////////////////////////////////////////////////////////////////
//
// homogenous filling:
//   generates points that nearly homogenously (low density fluctuations) fill some 2d area

void HomogenousFiller::Reset()
{
	num=0;
}

real HomogenousFiller::GetCirclePoint(real *a,real *b)
{
	real dist;
	do GetTrianglePoint(a,b); while((dist=*a**a+*b**b)>=SHOOT_FULL_RANGE);
	return dist;
}

void HomogenousFiller::GetTrianglePoint(real *a,real *b)
{
	unsigned n=num++;
	static const real dir[4][3]={{0,0,-0.5f},{0,1,0.5f},{0.86602540378444f,-0.5f,0.5f},{-0.86602540378444f,-0.5f,0.5f}};
	real x=0;
	real y=0;
	real dist=1;
	while(n)
	{
		x+=dist*dir[n&3][0];
		y+=dist*dir[n&3][1];
		dist*=dir[n&3][2];
		n>>=2;
	}
	*a=x;
	*b=y;
	//*a=rand()/(RAND_MAX*0.5)-1;
	//*b=rand()/(RAND_MAX*0.5)-1;
}


//////////////////////////////////////////////////////////////////////////////
//
// random exiting ray

bool Scene::getRandomExitDir(const Vec3& norm, const Vec3& u3, const Vec3& v3, const RRSideBits* sideBits, Vec3& exitDir)
// ortonormal space: norm, u3, v3
// returns random direction exitting diffuse surface with 1 or 2 sides and normal norm
{
#ifdef HOMOGENOUS_FILL
	real x,y;
	real cosa=sqrt(1-filler.GetCirclePoint(&x,&y));
#else
	// select random vector from srcPoint3 to one halfspace
	// power is assumed to be 1
	real tmp=(real)rand()/RAND_MAX*SHOOT_FULL_RANGE;
	real cosa=sqrt(1-tmp);
#endif
	// emit only inside?
	if(!sideBits[0].emitTo && sideBits[1].emitTo)
		cosa=-cosa;
	// emit to both sides?
	if(sideBits[0].emitTo && sideBits[1].emitTo)
		if((rand()%2)) cosa=-cosa;
	// don't emit?
	if(!sideBits[0].emitTo && !sideBits[1].emitTo)
		return false;
#ifdef HOMOGENOUS_FILL
	exitDir = norm*cosa + u3*x + v3*y;
#else
	real sina=sqrt( tmp );                  // a = rotation angle from normal to side, sin(a) = distance from center of circle
	Angle b=rand()*2*M_PI/RAND_MAX;         // b = rotation angle around normal
	exitDir = norm*cosa + u3*(sina*cos(b)) + v3*(sina*sin(b));
#endif
	RR_ASSERT(fabs(size2(exitDir)-1)<0.001);//ocekava normalizovanej dir
	return true;
}

Triangle* Scene::getRandomExitRay(Node *sourceNode, Vec3* src, Vec3* dir)
// returns random point and direction exiting sourceNode
{
	SubTriangle *source;
	{
		source=SUBTRIANGLE(sourceNode);
	}
	RR_ASSERT(!IS_CLUSTER(source));

	// select random point in source subtriangle
	unsigned u=rand();
	unsigned v=rand();
	if(u+v>RAND_MAX)
	{
		u=RAND_MAX-u;
		v=RAND_MAX-v;
	}
	Point2 srcPoint2=source->uv[0]+source->u2*(u/(real)RAND_MAX)+source->v2*(v/(real)RAND_MAX);
	Point3 srcPoint3=source->grandpa->to3d(srcPoint2);

	RR_ASSERT(source->grandpa->surface);
	Vec3 rayVec3;
	if(!getRandomExitDir(source->grandpa->getN3(),source->grandpa->getU3(),source->grandpa->getV3(),source->grandpa->surface->sideBits,rayVec3)) 
		return NULL;
	RR_ASSERT(IS_SIZE1(rayVec3));

	*src = srcPoint3;
	*dir = rayVec3;

	return source->grandpa;
}
/*
Channels Scene::getRadiance(Point3 eye,Vec3 direction,Triangle *skip,Channels visibility)
{
	RR_ASSERT(IS_VEC3(eye));
	RR_ASSERT(IS_VEC3(direction));
	RR_ASSERT(fabs(size2(direction)-1)<0.001);//ocekava normalizovanej dir
	RRRay& ray = *sceneRay;
	ray.rayOrigin = eye;
	ray.rayDirInv[0] = 1/direction[0];
	ray.rayDirInv[1] = 1/direction[1];
	ray.rayDirInv[2] = 1/direction[2];
	skipTriangle.skip = (unsigned)(skip-object->triangle);
	Triangle* hitTriangle = (object->triangles // although we may dislike it, somebody may feed objects with no faces which confuses intersect_bsp
		&& object->importer->getCollider()->intersect(&ray)) ? &object->triangle[ray.hitTriangle] : NULL;
	__shot++;
	//LOG_RAY(eye,direction,hitTriangle?ray.hitDistance:0.2f,hitTriangle);
	if(!hitTriangle)
	{
		// ray left scene
		if(environment)
		, hit environment
		RRVec3 irrad = tools.environment->getValue(dir);
		if(tools.scaler) tools.scaler->getPhysicalScale(irrad);
		maxSingleRayContribution = MAX(maxSingleRayContribution,irrad.sum());
		irradianceHemisphere += irrad;
		return Channels(0);
	}
	if(!hitTriangle->surface)
	{
		// error (bsp se generuje z meshe a surfacu(null=zahodit face), bsp hash se generuje jen z meshe. -> po zmene materialu nacte stary bsp a zasahne triangl ktery mel surface ok ale nyni ma NULL)
		RR_ASSERT(0);
		return Channels(0);
	}
	RR_ASSERT(hitTriangle->u2.y==0);
	RR_ASSERT(IS_NUMBER(ray.hitDistance));

	RRSideBits side=hitTriangle->surface->sideBits[ray.hitFrontSide?0:1];
	Channels exitance = Channels(0);
	if(side.legal && (side.catchFrom || side.emitTo))
	{
		// per-pixel material
		const RRMaterial* material = hitTriangle->surface;
		RRMaterial pointMaterial;
		if(side.pointDetails)
		{
			material = &pointMaterial;
			object->importer->getPointMaterial(ray.hitTriangle,ray.hitPoint2d,pointMaterial);
			side = pointMaterial.sideBits[ray.hitFrontSide?0:1];
		}

		// diffuse reflection
		if(side.emitTo)
		{
			Channels incidentPower = hitTriangle->totalIncidentFlux;
			Channels irradiance = incidentPower / hitTriangle->area;
			exitance += visibility * irradiance * material->diffuseReflectance;
			//!!! /2 kdyz emituje do obou stran
		}

		// specular reflection
		if(side.reflect)
		if(sum(abs(visibility*material->specularReflectance))>0.1)
		{
			// calculate hitpoint
			Point3 hitPoint3d=eye+direction*ray.hitDistance;
			// calculate new direction after ideal mirror reflection
			Vec3 newDirection=hitTriangle->getN3()*(-2*dot(direction,hitTriangle->getN3())/size2(hitTriangle->getN3()))+direction;
			// recursively call this function
			exitance += getRadiance(hitPoint3d,newDirection,hitTriangle,visibility*material->specularReflectance);
		}
	
		// specular transmittance
		if(side.transmitFrom)
		if(sum(abs(visibility*material->specularTransmittance))>0.1)
		{
			// calculate hitpoint
			Point3 hitPoint3d=eye+direction*ray.hitDistance;
			// calculate new direction after refraction
			Vec3 newDirection=-refract(hitTriangle->getN3(),direction,material->refractionIndex);
			// recursively call this function
			exitance += getRadiance(hitPoint3d,newDirection,hitTriangle,visibility*material->specularTransmittance);
		}
	}
	return exitance;
}*/

//////////////////////////////////////////////////////////////////////////////
//
// one shot from subtriangle to whole halfspace

void Scene::shotFromToHalfspace(Node *sourceNode)
{
	Vec3 srcPoint3,rayVec3;
	Triangle* tri=getRandomExitRay(sourceNode,&srcPoint3,&rayVec3);
	// cast ray
	if(tri) rayTracePhoton(srcPoint3,rayVec3,tri);
}

//////////////////////////////////////////////////////////////////////////////
//
// distribute energy via one factor

static void distributeEnergyViaFactor(Factor *factor,va_list ap)
{
	DBGLINE
	Channels energy=*va_arg(ap,Channels*);
	Reflectors *staticReflectors=va_arg(ap,Reflectors *);

	// statistics
	STATISTIC_INC(numCallsDistribFactor);
	//RRStaticSolver::getSceneStatistics()->sumDistribInput += energy;

	Node *destination=factor->destination;
	RR_ASSERT(destination);
	RR_ASSERT(factor->power>=0);
	// Power muze byt vic nez 1 uplne kdykoliv, viz komentar u rayTracePhoton().
	//RR_ASSERT(factor->power<=1 || factor->destination->grandpa->surface->specularTransmittance>0); // power>1 may occur only on transparent surfaces
	energy*=factor->power;
	// kdyz miri nad shooterlevel, presmeruje se dolu
	//...
	// nastavi nektery dirty
	//...mozna by jednou stacilo DIRTY_ALL_SUBNODES na cluster a nedistribuovat to dolu do trianglu
	// ve sponze zralo vetsinu vykonu 
	// flagy pouziva pouze externi rr\render.cpp, interne nejsou potreba
	// at si to rr\render.cpp zaridi jinak
	//if(IS_CLUSTER(destination))
	//	CLUSTER(destination)->makeDirty();
	//else
	//	SUBTRIANGLE(destination)->makeDirty();

	Channels energyIncident = energy;
#ifdef CLEAN_FACTORS
	RR_ASSERT(destination->grandpa);
	RR_ASSERT(destination->grandpa->surface);
	RR_ASSERT(IS_VEC3(destination->grandpa->surface->diffuseReflectance));
	// kdyz se aspon polovinu casu hybe svetly (hodne se distribuuje),
	//  tento radek je nejvetsi zrout CPU z celeho rr.
	// pri predelani cele matematiky na sse se vyrazne zrychli, ale jine vypocty 
	//  zpomali, protoze msvc neumi volaci konvence s predavanim sse registru.
	energy *= destination->grandpa->surface->diffuseReflectance;

	// statistics
	//RRStaticSolver::getSceneStatistics()->sumDistribFactorClean += factor->power;
	//RRStaticSolver::getSceneStatistics()->sumDistribFactorMaterial += destination->grandpa->surface->diffuseReflectance * factor->power;
#else
	//RRStaticSolver::getSceneStatistics()->sumDistribFactorClean += factor->power / destination->grandpa->surface->diffuseReflectance;
	//RRStaticSolver::getSceneStatistics()->sumDistribFactorMaterial += factor->power;
#endif
	//RRStaticSolver::getSceneStatistics()->sumDistribOutput += energy;

	// pak leze nahoru az k trianglu, do clusteru neni treba
	bool wasLetToDiffuse=false;
	do
	{
		destination->totalExitingFlux+=energy;
		destination->totalIncidentFlux+=energyIncident;
#ifndef CLEAN_FACTORS
#error Filling totalIncidentFlux requires CLEAN_FACTORS.
#endif
		destination->flags|=FLAG_DIRTY_NODE;
		if(destination->shooter && !wasLetToDiffuse)
		{
			destination->shooter->totalExitingFluxToDiffuse+=energy;
			staticReflectors->insert(destination);
			wasLetToDiffuse=true;
		}
		destination=destination->parent;
	}
	while(destination /*&& !IS_CLUSTER(destination)*/); //...proc je to zakomentovany?
	RR_ASSERT(wasLetToDiffuse);
	// stara verze bez zmeny levelu
	//factor->destination->totalExitingFluxToDiffuse+=energy*factor->power;
	DBGLINE
}

//////////////////////////////////////////////////////////////////////////////
//
// read and clear hits, possibly split to subtriangles, set form factors
// return if clustering with brother is possible

bool Scene::setFormFactorsTo(Node *source,Point3 (*sourceVertices)[3],Factors *factors,SubTriangle *destination,Hits *phits,int shots)
{
	DBGLINE
	RR_ASSERT(destination);
	RR_ASSERT(phits);
	if(phits->hits==0) return true;

	// special short path for disabled subdivision
	if(!object->subdivisionSpeed)
		goto dont_split;

	bool doSplit;
	{
		Point2 triCentre=destination->uv[0]+(destination->u2+destination->v2)/3;
		real perimeter=destination->perimeter();
		doSplit=phits->doSplit(triCentre,perimeter,destination->grandpa);
		//	real difBtwAvgHitAndCen=destination->phits->difBtwAvgHitAnd(triCentre);
		//	bool doSplit=difBtwAvgHitAndCen*destination->phits->count>perimeter/MESHING;
	}
	if(doSplit)
	{
		DBGLINE
		destination->splitGeometry(NULL);
		DBGLINE
		Hits *phits2=allocHitsLevel();
		destination->splitHits(phits,phits2);
		setFormFactorsTo(source,sourceVertices,factors,SUBTRIANGLE(destination->sub[0]),phits2,shots);
		freeHitsLevel();
		setFormFactorsTo(source,sourceVertices,factors,SUBTRIANGLE(destination->sub[1]),phits,shots);
		DBGLINE
		return false;
	}
	else
	{
dont_split:
		DBGLINE
		real ff;
		/*if(sourceVertices)
		{
			Point3 destinationVertices[3]={destination->to3d(0),destination->to3d(1),destination->to3d(2)};
			ff=FormFactorf((real (*)[3])sourceVertices,3,(real (*)[3])destinationVertices,3);
			RR_ASSERT(ff>=0);
			RR_ASSERT(ff<=1);
		}
		else*/
		{
			ff=phits->totalPower()/shots;
			// ff muze vyjit >1 kdyz se paprsek lame v pruhlednem objektu a nekolikrat zasahne stejny triangl
			//printf("insert %f = %f/%d * %f\n",ff*destination->grandpa->surface->diffuseReflectance,phits->totalPower(),shots,destination->grandpa->surface->diffuseReflectance);

			// muze byt i hits>shots (napr. 1 shot, 2 hits, kdyz se paprsek odrazi od lesklyho/pruhlednyho povrchu a vickrat zasahne tentyz triangl)
			// mohou ty 2 hity mit dohromady power>1?
			// odpoved skryva rayTracePhoton():
			//  - to co vraci by s korektnimi materialy nemelo prekrocit 1
			//    (to ale nikoho nezajima, nikam se to nezapisuje)
			//  - to co zapisuje do 
		}
		// hit powers are not multiplied by surface reflectance, it must be done here (premultiplication=loss of precision)
#ifdef CLEAN_FACTORS
		factors->insert(Factor(destination,ff));
#else
		factors->insert(Factor(destination,ff*destination->grandpa->surface->diffuseReflectance));
#endif
		phits->reset();
		DBGLINE
		return true;
	}
}


//////////////////////////////////////////////////////////////////////////////
//
// refresh form factors from one source to all destinations that need it
// split triangles and subtriangles if needed

void Scene::refreshFormFactorsFromUntil(Node *source,unsigned forcedShotsForNewFactors,bool endfunc(void *),void *context)
{
	CHECK_HEAP;
	DBGLINE
	if(phase==0)
	{
		DBGLINE
		// prepare shooting
		RR_ASSERT(source->shooter);
		shotsForNewFactors = forcedShotsForNewFactors ? forcedShotsForNewFactors : (source->shooter->shotsForFactors?REFRESH_MULTIPLY*source->shooter->shotsForFactors:REFRESH_FIRST);
		if(!forcedShotsForNewFactors)
			RR_ASSERT(shotsForNewFactors>source->shooter->shotsForFactors);
		RR_ASSERT(shotsAccumulated==0);
		RR_ASSERT(!hitTriangles.get());
		filler.Reset(); // prepare homogenous shooting
		phase=1;
	}
	CHECK_HEAP;
	if(phase==1)
	{
		DBGLINE
		// shoot
		while(shotsAccumulated<shotsForNewFactors
			)
		{
			shotFromToHalfspace(source);
			shotsAccumulated++;
			shotsTotal++;
			if(shotsTotal%10==0) if(endfunc(context)) return;
		}
		phase=2;
	}
	CHECK_HEAP;
	if(phase==2)
	{
		DBGLINE
		// kontrola ze jsou flagy opravdu vsude ciste
		RR_ASSERT(object->check());
		RR_ASSERT(improvingFactors.factors()==0);
		hitTriangles.holdAmulet();
		phase=3;
	}
	CHECK_HEAP;
	if(phase==3)
	{
		DBGLINE
		// analyze and remove hits and calculate new factors
/*
    zpracovani hitTriangles s plnenim candidates a moles
    moles oflagujou cestu nahoru ze se zamita
    candidates oflagujou cestu nahoru ze tamtudy pujdou
     (jeste se nevi jestli s nabidkou nebo zamitnutim)
    zpracovani candidates
     bratr zamita -> koncime tam kde jsme
     bratr nabizi -> lze se spojit a jit nahoru
     bratr neoflagovany -> nebyl zasazen, lze jit nahoru
     bratr vaha -> zastavime kde jsme, bratr nas pozdejc vyveze az pojede
      sam nahoru nebo nas necha kdyz nepojede
    o(h+c)
*/
		Triangle *hitTriangle;

		while((hitTriangle=hitTriangles.get())
			)
		{
			Point3 sourceVertices[3];
			Point3 (*sourceVerticesPtr)[3]=NULL;
			if(!IS_CLUSTER(source))
			{
				sourceVertices[0]=SUBTRIANGLE(source)->to3d(0);
				sourceVertices[1]=SUBTRIANGLE(source)->to3d(1);
				sourceVertices[2]=SUBTRIANGLE(source)->to3d(2);
				sourceVerticesPtr=&sourceVertices;
			}
			// do improvingFactors sype generovane faktory
			if(setFormFactorsTo(source,sourceVerticesPtr,&improvingFactors,hitTriangle,&hitTriangle->hits,shotsAccumulated) && hitTriangle->parent)
			{
			}
			// pokud je treba setrit pameti, uvolni buffer po hitech
			hitTriangle->compact();
			if(endfunc(context)) return;
		}
		hitTriangles.reset();
		// kontrola ze jsou flagy opravdu vsude ciste
		RR_ASSERT(object->check());

		// take back energy distributed via old factors
		shotsForFactorsTotal-=source->shooter->shotsForFactors;
		Channels ch(-source->shooter->totalExitingFluxDiffused);
		source->shooter->forEach(distributeEnergyViaFactor,&ch/*-source->shooter->totalExitingFluxDiffused*/,&staticReflectors);
		source->shooter->totalExitingFluxToDiffuse+=source->shooter->totalExitingFluxDiffused;
		source->shooter->totalExitingFluxDiffused=Channels(0);
		source->shooter->shotsForFactors=shotsAccumulated;
		shotsAccumulated=0;
		shotsForFactorsTotal+=source->shooter->shotsForFactors;
		// install new factors
		source->shooter->Factors::reset();
		source->shooter->insert(&improvingFactors);
		improvingFactors.reset();
		phase=0;
	}
	DBGLINE
	CHECK_HEAP;
}

real Scene::avgAccuracy()
{
	return (1+shotsForFactorsTotal)/sum(abs(staticSourceExitingFlux));
}

//////////////////////////////////////////////////////////////////////////////
//
// distribute energy from source
// refresh form factors and split triangles and subtriangles if needed
// return if everything was distributed

// vraci true pri improved
bool Scene::energyFromDistributedUntil(Node *source,bool endfunc(void *),void *context)
{
	CHECK_HEAP;
	// refresh unaccurate form factors
	RR_ASSERT(staticReflectors.check());
	bool needsRefresh = staticReflectors.lastBestWantsRefresh();
	if(phase==0)
	{
		if(needsRefresh)
		{
			STATISTIC_INC(numCallsRefreshFactors);
		}
		else
		{
			STATISTIC_INC(numCallsDistribFactors);
		}
	}
	RR_ASSERT(staticReflectors.check());
	CHECK_HEAP;
	if(needsRefresh)
	{
		refreshFormFactorsFromUntil(source,0,endfunc,context);
	}
	CHECK_HEAP;
	RR_ASSERT(staticReflectors.check());
	if(phase==0)
	{
		// distribute energy via form factors
		RR_ASSERT(source->shooter);
		RR_ASSERT(staticReflectors.check());
		source->shooter->forEach(distributeEnergyViaFactor,&source->shooter->totalExitingFluxToDiffuse,&staticReflectors);
		RR_ASSERT(staticReflectors.check());
		source->shooter->totalExitingFluxDiffused+=source->shooter->totalExitingFluxToDiffuse;
		source->shooter->totalExitingFluxToDiffuse=Channels(0);
		RR_ASSERT(staticReflectors.check());
		CHECK_HEAP;
		return true;
	}
	RR_ASSERT(staticReflectors.check());
	CHECK_HEAP;
	return false;
}

//////////////////////////////////////////////////////////////////////////////
//
// improve global illumination in scene by only distributing energy

bool Scene::distribute(real maxError)
{
	DBGLINE
	//if(phase==3) return false; myslim ze zadna phase nebrani distribuci
	bool distributed=false;
	int steps=0;
	int rezerva=20;
	while(1)
	{
		Node *source=staticReflectors.best(sum(abs(staticSourceExitingFlux)),object->subdivisionSpeed);
//if(source) printf(" %f<%f\n",fabs(source->shooter->totalExitingFluxToDiffuse),fabs(maxError*energyEmitedByStatics));
		if(!source || ( sum(abs(source->shooter->totalExitingFluxToDiffuse))<sum(abs(staticSourceExitingFlux*maxError)) && !rezerva--)) break;
		RR_ASSERT(source->shooter);
		source->shooter->forEach(distributeEnergyViaFactor,&source->shooter->totalExitingFluxToDiffuse,&staticReflectors);
		source->shooter->totalExitingFluxDiffused+=source->shooter->totalExitingFluxToDiffuse;
		source->shooter->totalExitingFluxToDiffuse=Channels(0);
		steps++;
		distributed=true;
	}
//printf("%i\n",steps);
	DBGLINE
	return distributed;
}

//////////////////////////////////////////////////////////////////////////////
//
// improve global illumination in scene

RRStaticSolver::Improvement Scene::improveStatic(bool endfunc(void *), void *context)
{
	if(!IS_CHANNELS(staticSourceExitingFlux)) return RRStaticSolver::INTERNAL_ERROR; // invalid internal data
	DBGLINE
	STATISTIC_INC(numCallsImprove);
	RRStaticSolver::Improvement improved=RRStaticSolver::NOT_IMPROVED;

	do
	{
		RR_ASSERT(staticReflectors.check());
		if(improvingStatic==NULL)
			improvingStatic=staticReflectors.best(sum(abs(staticSourceExitingFlux)),object->subdivisionSpeed);
		if(improvingStatic==NULL) 
		{
			improved = RRStaticSolver::FINISHED;
			break;
		}
		RR_ASSERT(staticReflectors.check());
		if(energyFromDistributedUntil(improvingStatic,endfunc,context))
		{
			improvingStatic=NULL;
			improved=RRStaticSolver::IMPROVED;
		}
		RR_ASSERT(staticReflectors.check());
	}
	while(!endfunc(context));

	DBGLINE
	return improved;
}

//////////////////////////////////////////////////////////////////////////////
//
// abort/shorten/finish previously started improvement

void Scene::abortStaticImprovement()
{
	if(improvingStatic)
	{
		Triangle *hitTriangle;
		while((hitTriangle=hitTriangles.get())) hitTriangle->hits.reset();
		hitTriangles.reset();
		improvingFactors.reset();
		shotsAccumulated=0;
		phase=0;
		improvingStatic=NULL;
		// kontrola ze jsou flagy opravdu vsude ciste
		RR_ASSERT(object->check());
	}
}

// skonci pokud uz je hitu aspon tolikrat vic nez kolik bylo pouzito na stavajici kvalitu

bool Scene::shortenStaticImprovementIfBetterThan(real minimalImprovement)
{
	RR_ASSERT((improvingStatic!=NULL) == (phase!=0));
	if(improvingStatic)
	{
		// za techto podminek at uz dal nestrili
		if(phase==1 && shotsAccumulated>=minimalImprovement*improvingStatic->shooter->shotsForFactors) phase=2;
		// vraci uspech pokud uz nestrili ale jeste neskoncil
		return phase>=2;
	}
	return false;
}

bool falsefunc(void *scene)
{
	return false;
}

bool Scene::finishStaticImprovement()
{
	RR_ASSERT((improvingStatic!=NULL) == (phase!=0));
	if(improvingStatic)
	{
		RR_ASSERT(phase>0);
		bool e=energyFromDistributedUntil(improvingStatic,falsefunc,NULL);
		RR_ASSERT(e); e=e;
		RR_ASSERT(phase==0);
		improvingStatic=NULL;
		return true;
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////////
//
// instant radiosity


//////////////////////////////////////////////////////////////////////////////
//
// infos

void Scene::infoScene(char *buf)
{
	sprintf(buf,"vertices=%d triangles=%d",object->vertices,object->triangles);
}

void Scene::infoStructs(char *buf)
{
	int no=sizeof(Node);
	int cl=0;
	int su=sizeof(SubTriangle);
	int tr=sizeof(Triangle);
	int hi=sizeof(Hit);
	int fa=sizeof(Factor);
	int iv=0;
	int co=0;
	int ed=0;
	iv=sizeof(IVertex);
	co=sizeof(Corner);
	ed=sizeof(Edge);
	sprintf(buf,"no=%i,cl=%i,su=%i,tr=%i  hi=%i,fa=%i  iv=%i,co=%i,ed=%i)",no,cl,su,tr, hi,fa, iv,co,ed);
}

void Scene::infoImprovement(char *buf, int infolevel)
{
	int kb=0;
	int hi=sizeof(Hit)*__hitsAllocated;
	int fa=sizeof(Factor)*__factorsAllocated;
	int su=sizeof(SubTriangle)*(__subtrianglesAllocated-__trianglesAllocated);
	int tr=sizeof(Triangle)*__trianglesAllocated;
	int cl=0;
	int iv=0;
	int co=0;
	iv=sizeof(IVertex)*__iverticesAllocated;
	co=sizeof(Corner)*__cornersAllocated;
	int ot=kb-hi-fa-su-tr-cl-iv-co;
	buf[0]=0;
	STATISTIC(if(infolevel>1) sprintf(buf+strlen(buf),"hits(%i/%i) ",RRStaticSolver::getSceneStatistics()->numRayTracePhotonFrontHits,RRStaticSolver::getSceneStatistics()->numRayTracePhotonBackHits));
	//sprintf(buf+strlen(buf),"kb=%i",kb/1024);
	if(infolevel>1) sprintf(buf+strlen(buf),"(hi=%i,fa=%i,su=%i,tr=%i,cl=%i,iv=%i,co=%i,ot=%i)",
		hi/1024,fa/1024,su/1024,tr/1024,cl/1024,iv/1024,co/1024,ot/1024);
	sprintf(buf+strlen(buf)," meshes=%i/%i rays=(%i)%i",staticReflectors.nodes,__nodesAllocated,shotsTotal,shotsForFactorsTotal);
	if(improvingStatic) sprintf(buf+strlen(buf),"(%i/%i->%i)",shotsAccumulated,improvingStatic->shooter->shotsForFactors,shotsForNewFactors);
	RR_ASSERT((improvingStatic!=NULL) == (phase!=0));
}

void Scene::getStats(unsigned* faces, RRReal* sourceExitingFlux, unsigned* rays, RRReal* reflectedIncidentFlux) const
{
#if CHANNELS == 3
	if(faces) 
	{
		*faces = object->triangles;
	}
	if(sourceExitingFlux) *sourceExitingFlux = sum(staticSourceExitingFlux);
	if(rays) *rays = shotsTotal;
	if(reflectedIncidentFlux) *reflectedIncidentFlux = 0;//!!!sum(staticReflectedIncidentFlux);
#else
	#error Only Channels=3 supported here.
#endif
}

void core_Done()
{
#ifndef NDEBUG
	if( __nodesAllocated
	 || __subtrianglesAllocated
	 || __trianglesAllocated
	 || __edgesAllocated
	 || __hitsAllocated
	 || __factorsAllocated
	 || __iverticesAllocated
	 || __cornersAllocated
	  )
	{
	  fprintf(stderr," nodes       =%8d %8dK\n subtriangles=%8d %8dK\n triangles   =%8d %8dK\n clusters    =%8d %8dK\n edges       =%8d %8dK\n hits        =%8d %8dK\n factors     =%8d %8dK\n",
	    __nodesAllocated,__nodesAllocated*sizeof(Node)/1024,
	    __subtrianglesAllocated,__subtrianglesAllocated*sizeof(SubTriangle)/1024,
	    __trianglesAllocated,__trianglesAllocated*sizeof(Triangle)/1024,
		0,0,
	    __edgesAllocated,__edgesAllocated*sizeof(Edge)/1024,
	    __hitsAllocated,__hitsAllocated*sizeof(Hit)/1024,
	    __factorsAllocated,__factorsAllocated*sizeof(Factor)/1024);
	  fprintf(stderr," ivertices   =%8d %8dK\n corners     =%8d %8dK\n",
	    __iverticesAllocated,__iverticesAllocated*sizeof(IVertex)/1024,
	    __cornersAllocated,__cornersAllocated*sizeof(Corner)/1024);
	  //fgetc(stdin);
	}
#endif

}

} // namespace

/*
buga v interpolaci na vrsku 8stennyho bodaku
pocitat pri gouraudu i totalExitingFlux z clusteru
pocitat pri flatu i totalExitingFlux z clusteru
reflector meshing je pomalej protoze pulreflektory nemaj energii na strileni, musi se odebrat reflektoru a dat jim.
Factor *factor alokovat az pri prvnim insertu
co pujde z Shooter presunout do Scene
*/

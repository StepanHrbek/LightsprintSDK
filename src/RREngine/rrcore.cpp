#include <assert.h>
#ifndef _MSC_VER
#include <inttypes.h> // intptr_t
#endif
#include <math.h>
#include <memory.h>
#include <stdarg.h>
#include <stddef.h>   // intptr_t
#include <stdio.h>    // printf na debugink
#include <stdlib.h>
#include <string.h>
#include <time.h>     // gate
//#define SUPPORT_PNG
#ifdef SUPPORT_LIGHTMAP
 #ifdef SUPPORT_PNG
  #include <png.h>
 #endif
#endif
//#include "libff/ff.h"
#include "rrcore.h"

namespace rrEngine
{

#define ALLOW_DEGENS              // accept triangles degenerated by low numerical quality float operations
#define HOMOGENOUS_FILL           // shooting direction is not random but fractal, 0% space, -2% calc
#define CLEAN_FACTORS             // pure geometry factors not multiplied by destination material, -1%calc (YES = allows calculations with different components, NO = allows full clustering, factors may direct to clusters)
#define MESHING              RRGetStateF(RRSSF_SUBDIVISION_SPEED)    // 0.3=few meshes, 1=default, 3=many meshes (noise)
#define REFLECTOR_MESHING    2.5  // 1=no subreflectors, 10=possibility of many meshes
#define SHOOT_FULL_RANGE     1    // 89/90=ignore 1 degree near surface, shoot only away from surface (to avoid occasional shots inside object)
#define MAX_CLUSTER_ANGLE_B  (M_PI/2-0.01)// max angle between neighbours in cluster (big)
#define MAX_CLUSTER_ANGLE_S  (M_PI/4-0.01)// max angle between neighbours in cluster (small)
#define HITS_TO_COMPACT      1000000  // if more or equal bytes may be freeed, do it after each shooting. may help to save memory for big scenes. warning: low number=+10%cpu
//#define DEBUK
//#define LOG_LOADING_MES

#ifdef _MSC_VER
//error : inserted by sunifdef: "#define GATE_DATE" contradicts -U at R:\work2\.git-rewrite\t\src\RREngine\rrcore.cpp~(38)
//error : inserted by sunifdef: "#define GATE_SHOTS 10000 // max photons from one shooter" contradicts -U at R:\work2\.git-rewrite\t\src\RREngine\rrcore.cpp~(39)
//error : inserted by sunifdef: "#define GATE_QUALITY 5000000 // max photons in scene" contradicts -U at R:\work2\.git-rewrite\t\src\RREngine\rrcore.cpp~(40)
//error : inserted by sunifdef: "#define GATE_IP" contradicts -U at R:\work2\.git-rewrite\t\src\RREngine\rrcore.cpp~(41)
//#define GATE_IP_DEE // off
//#define GATE_RAYS // off
#endif

#define TWOSIDED_RECEIVE_FROM_BOTH_SIDES
#define TWOSIDED_EMIT_TO_BOTH_SIDES
#define ONESIDED_TRANSMIT_ENERGY

#define PHOTOMETRIC_R        1//0.265f
#define PHOTOMETRIC_G        1//0.670f
#define PHOTOMETRIC_B        1//0.065f

// vyznam ve vypoctu odrazene energie je podil prislusne komponenty v namerene
// hodnote photometric reflectance. spravne hodnoty mi nejsou znamy.
//   Photometric reflectance is measured according to v(lambda)
//   response function of the 1931 CIE standard 2
//   degree observer, and assumes an equal-energy white light source.

// vyznam ve vypoctu emitovane energie je podil prislusne komponenty v namerene
// hodnote photometric emittance. spravne hodnoty mi nejsou znamy.
//   Set the diffuse emittance for the current material to epsilon_d
//   lumens per square meter using the current color to determine the
//   spectral characteristics.
//   Note that this is emittance rather than exitance, and therefore
//   does not include reflected or transmitted light, which is a function
//   of the other material settings and the illuminated environment.

// pravdepodobne jsem nasel spravne hodnoty photometric brightness:
//   cmix entity sums together two or more named colors using specified
//   weighting coefficients, which correspond to the relative
//   photometric brightness of each.
//   # Define RGB primaries for a standard color monitor
//   c R =
// 	cxy 0.640 0.330
//   c G =
// 	cxy 0.290 0.600
//   c B =
// 	cxy 0.150 0.060
//   # Mix them together in appropriate amounts for white
//   c white =
// 	cmix 0.265 R 0.670 G 0.065 B


//////////////////////////////////////////////////////////////////////////////
//
// memory

#ifndef ONLY_PLAYER

#define SIMULATE_REALLOC

void* realloc(void* p,size_t oldsize,size_t newsize)
{
#ifdef SIMULATE_REALLOC
	//if(newsize>500000) return realloc(p,newsize);
	// this simulated realloc prevents real but buggy realloc from crashing rr (seen in DJGPP)
	// it is also faster (seen in MinGW)
	void *q=malloc(newsize);
	if(p)
	{
		memcpy(q,p,MIN(oldsize,newsize));
		free(p);
	}
	return q;
#else
	return realloc(p,newsize);
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// globals

bool  __errors=false; // was there errors during batch work? used to set result

unsigned  __frameNumber=1; // frame number increased after each draw

RRColor __colorFilter={1,1,1}; // see rrcore.h

bool  __preserveFactors=false; // preserve factors in Factors::reset(), needed if we want resetStaticIllumination() but not factors

//////////////////////////////////////////////////////////////////////////////
//
// hit to subtriangle

real Hit::getPower()
{
#ifdef HITS_FIXED
	return power/(HITS_P_MAX*1.0);
#else
	return power;
#endif
}

void Hit::setPower(real apower)
{
	assert(apower>=-1 && apower<=1);
#ifdef HITS_FIXED
	power=(HITS_P_TYPE)(apower*HITS_P_MAX);
#else
	power=apower;
#endif
}

void Hit::setExtensionP(void *ext)
{
#ifdef HITS_FIXED
#else
	power=*(real *)&ext;
#endif
}

void *Hit::getExtensionP()
{
#ifdef HITS_FIXED
	#ifdef SUPPORT_DYNAMIC
	  #error HITS_FIXED + SUPPORT_DYNAMIC not allowed
	#endif
	return NULL; // won't be called
#else
	return *(void **)&power;
#endif
}

void Hit::setExtensionR(real r)
{
	setExtensionP(*((void **)&r));
}

real Hit::getExtensionR()
{
	void *p=getExtensionP();
	return *((real *)&p);
}

//////////////////////////////////////////////////////////////////////////////
//
// hits to one subtriangle

unsigned __hitsAllocated=0;
Scene* __gscene=NULL;

Hits::Hits()
{
	hitsAllocated=0;
	hit=NULL;
	reset();
}

void Hits::reset()
{
	hits=0;
	sum_u=0;
	sum_v=0;
	sum_power=0;
#ifdef SUPPORT_DYNAMIC
	// jen pro klid, nemuselo by se cistit
	isDynamic=false;
#endif
}

void Hits::rawInsert(Hit HIT_PTR ahit)
{
	if(!hitsAllocated)
	{
		hitsAllocated=16;
		hit=(Hit *)malloc(hitsAllocated*sizeof(Hit));
		__hitsAllocated+=hitsAllocated;
	}
	else
	if(hits==hitsAllocated)
	{
		size_t oldsize=hitsAllocated*sizeof(Hit);
		__hitsAllocated+=3*hitsAllocated;
		hitsAllocated*=4;
		hit=(Hit *)realloc(hit,oldsize,hitsAllocated*sizeof(Hit));
	}
	hit[hits++]=ahit;
	sum_u+=ahit.u;
	sum_v+=ahit.v;
	sum_power+=ahit.power;
#ifndef HITS_FIXED
	assert(IS_POWER(ahit.power));
#endif
}

void Hits::insert(Hit HIT_PTR ahit)
{
#ifdef SUPPORT_DYNAMIC
	assert(!isDynamic || !hits);
	isDynamic=false;
#endif
	rawInsert(ahit);
}

real Hits::difBtwAvgHitAnd(Point2 a,Triangle *base)
{
#ifdef HITS_FIXED
	assert(base->u2.y==0);
	#define WORD_TO_REAL_U(u,v) (((u)*base->u2.x+(v)*base->v2.x)/HITS_UV_MAX)
	#define WORD_TO_REAL_V(u,v) ((               (v)*base->v2.y)/HITS_UV_MAX)
	return size(Point2(
	  WORD_TO_REAL_U((real)(sum_u)/hits,(real)(sum_v)/hits)-a.x,
	  WORD_TO_REAL_V((real)(sum_u)/hits,(real)(sum_v)/hits)-a.y));
#else
	return size(Point2(sum_u/hits-a.x,sum_v/hits-a.y));
#endif
}

bool Hits::doSplit(Point2 centre,real perimeter,Triangle *base)
{
	return perimeter>1 && difBtwAvgHitAnd(centre,base)*hits>perimeter/MESHING;
}

/*real Hits::avgDifBtwHitAnd(Point2 a)
{
	real dif=0;
	for(unsigned i=0;i<count;i++)
#ifdef HITS_FIXED
		dif+=size(Point2(hit[i].u/(HITS_UV_MAX*1.0)-a.x,hit[i].v/(HITS_UV_MAX*1.0)-a.y));
#else
		dif+=size(Point2(hit[i].u-a.x,hit[i].v-a.y));
#endif
	return dif/count;
}*/

real Hits::totalPower()
{
#ifdef HITS_FIXED
	return sum_power/(HITS_P_MAX*1.0);
#else
	assert(IS_NUMBER(sum_power));
	return sum_power;
#endif
}

void Hits::compactImmediate()
{
	if(hitsAllocated && !hits)
	{
		free(hit);
		hit=NULL;
		__hitsAllocated-=hitsAllocated;
		hitsAllocated=0;
	}
}

void Hits::compact()
{
	if(hitsAllocated>=HITS_TO_COMPACT) compactImmediate();
}

Hits::~Hits()
{
	hits=0;
	compactImmediate();
}

//////////////////////////////////////////////////////////////////////////////
//
// form factor from implicit source to explicit destination

Factor::Factor(class Node *adestination,real apower)
{
	assert(apower>0); // power=0 has no sense to store
#ifdef CLEAN_FACTORS
#ifdef HITS_FIXED
	#warning With CLEAN_FACTORS + HITS_FIXED you may loose part of energy around partially transparent objects.
	if(apower>1) fprintf(stderr,"Turn off CLEAN_FACTORS or HITS_FIXED when using transparent materials.\n");
	assert(apower<=1);
#endif
#endif
	power=apower;
	destination=adestination;
}

//////////////////////////////////////////////////////////////////////////////
//
// all form factors from implicit source

unsigned __factorsAllocated=0;

Factors::Factors()
{
	factors24_allocated8=0;
	factor=NULL;
}

unsigned Factors::factors()
{
	return factors24_allocated8>>8;
}

unsigned Factors::factorsAllocated()
{
	return 1<<(factors24_allocated8&0xff);
}


void Factors::insert(Factor afactor)
{
	if(!factors24_allocated8)
	{
		factors24_allocated8=4;
		factor=(Factor *)malloc(factorsAllocated()*sizeof(Factor));
		__factorsAllocated+=factorsAllocated();
	}
	else
	if(factors()==factorsAllocated())
	{
		size_t oldsize=factorsAllocated()*sizeof(Factor);
		__factorsAllocated+=3*factorsAllocated();
		factors24_allocated8+=2;
		factor=(Factor *)realloc(factor,oldsize,factorsAllocated()*sizeof(Factor));
	}
	factor[factors()]=afactor;
	factors24_allocated8+=0x100;
}

void Factors::insert(Factors *afactors)
{
	if(!afactors->factors()) return;
	if(!factors24_allocated8)
	{
		factors24_allocated8=4;
		while(factorsAllocated()<factors()+afactors->factors()) factors24_allocated8++;
		factor=(Factor *)malloc(factorsAllocated()*sizeof(Factor));
		__factorsAllocated+=factorsAllocated();
	}
	else
	if(factorsAllocated()<factors()+afactors->factors())
	{
		size_t oldsize=factorsAllocated()*sizeof(Factor);
		while(factorsAllocated()<factors()+afactors->factors())
		{
			__factorsAllocated+=factorsAllocated();
			factors24_allocated8++;
		}
		factor=(Factor *)realloc(factor,oldsize,factorsAllocated()*sizeof(Factor));
	}
	memcpy(&factor[factors()],&afactors->factor[0],afactors->factors()*sizeof(Factor));
	factors24_allocated8+=afactors->factors()<<8;
}

Factor Factors::get()
{
	assert(factors());
	factors24_allocated8-=0x100;
	return factor[factors()];
}

real Factors::contains(Node *destination)
{
	for(unsigned i=0;i<factors();i++) if(factor[i].destination==destination)
	{
		return factor[i].power;
	}
	return -1;
}

void Factors::remove(Factor *afactor)
{
	assert(afactor>=factor && afactor<factor+factors());
	*afactor=factor[factors()-1];
	factors24_allocated8-=0x100;
}

void Factors::forEach(void (*func)(Factor *factor,va_list ap),...)
{
	va_list ap;
	va_start(ap,func);
	for(unsigned i=0;i<factors();i++) func(factor+i,ap);
	va_end(ap);
}

void Factors::forEachDestination(void (*func)(Node *node,va_list ap),...)
{
	va_list ap;
	va_start(ap,func);
	for(unsigned i=0;i<factors();i++) func(factor[i].destination,ap);
	va_end(ap);
}

void Factors::removeZeroFactors()
{
	for(int i=factors()-1;i>=0;i--)
	{
		if(!factor[i].destination)
		{
			factors24_allocated8-=0x100;
			factor[i]=factor[factors()];
		}
	}
}

void Factors::reset()
{
	factors24_allocated8&=0xff;
}

Factors::~Factors()
{
	if(factors24_allocated8)
	{
		free(factor);
		assert(__factorsAllocated>=factorsAllocated());
		__factorsAllocated-=factorsAllocated();
	}
}

Shooter::Shooter()
{
	reset();
}

void Shooter::reset()
{
	if(!__preserveFactors)
	{
		Factors::reset();
		shotsForFactors=0;
	}
	energyDiffused=Channels(0);
	energyToDiffuse=Channels(0);
	tmpFactor=NULL;
}

real Shooter::accuracy()
{
	return shotsForFactors/(sum(abs(energyDiffused+energyToDiffuse))+SMALL_ENERGY);
}

Shooter::~Shooter()
{
	assert(!tmpFactor);
}

//////////////////////////////////////////////////////////////////////////////
//
// LevelHits
//  each Triangle has its own Hits
//  SubTriangles allocate Hits here and return them here as soon as possible

struct LevelHits
{
	LevelHits();
	~LevelHits();

	Hits *allocLevel();
	void freeLevel();

	private:
		unsigned levelsAllocated;
		unsigned levels;
		Hits **level;
};

LevelHits::LevelHits()
{
	levels=0;
	levelsAllocated=0;
	level=NULL;
}

Hits *LevelHits::allocLevel()
{
	if(levels==levelsAllocated)
	{
		size_t oldsize=levelsAllocated*sizeof(Hits *);
		levelsAllocated+=16;
		level=(Hits **)realloc(level,oldsize,levelsAllocated*sizeof(Hits *));
		for(unsigned i=levels;i<levelsAllocated;i++)
			level[i]=new Hits;
	}
	assert(!level[levels]->hits);
	return level[levels++];
}

void LevelHits::freeLevel()
{
	assert(levels);
	assert(!level[levels-1]->hits);
	levels--;
}

LevelHits::~LevelHits()
{
	while(levelsAllocated--) delete level[levelsAllocated];
	free(level);
}

LevelHits *__levels;

Hits *allocHitsLevel()
{
	return __levels->allocLevel();
}

void freeHitsLevel()
{
	__levels->freeLevel();
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// node in hierarchy of clusters, triangles and subtriangles

unsigned __nodesAllocated=0;

#ifdef ONLY_PLAYER

Node::Node(Node *aparent,class Triangle *agrandpa)
{
	parent=aparent;
	grandpa=agrandpa;
	sub[0]=NULL;
	sub[1]=NULL;
	flags=0;
	__nodesAllocated++;
}

Node *Node::brother()
{
	assert(parent);
	return parent->sub[(this==parent->sub[0])?1:0];
}

Node::~Node()
{
	__nodesAllocated--;
}

#else

Node::Node(Node *aparent,class Triangle *agrandpa)
{
	parent=aparent;
	grandpa=agrandpa;
	shooter=parent?NULL:new Shooter();
	sub[0]=NULL;
	sub[1]=NULL;
	reset();
	__nodesAllocated++;
}

void Node::reset()
{
	energyDirect=Channels(0);
	flags=0;
#ifdef SUPPORT_DYNAMIC
	energyDynamicFrame=0;
	energyDynamicSmooth=0;
	energyDynamicVariance=0;
	energyDynamicFrameTime=0;
	energyDynamicSmoothTime=0;
#endif
	// clean subtriangles
	if(!IS_CLUSTER(this) && sub[0])
	{
		sub[0]->reset();
		sub[1]->reset();
	}
	// delete unwanted subtriangle shooters
	if(IS_SUBTRIANGLE(this))
	{
		if(shooter) delete shooter;
		shooter=NULL;
	}
	// reset wanted triangle and cluster shooters
	else
	{
		assert(shooter);
		shooter->reset();
	}
}

Node *Node::brother()
{
	assert(parent);
	return parent->sub[(this==parent->sub[0])?1:0];
}

bool Node::loadEnergyFromSubs()
{
	assert(sub[0]);
	assert(sub[1]);
//        assert(area==0);
//        area=sub[0]->area+sub[1]->area;
//        assert(energyDirect==0);
	energyDirect=sub[0]->energyDirect+sub[1]->energyDirect;
	assert(sub[0]->shooter);
	assert(sub[1]->shooter);
	Channels tmp0=sub[0]->shooter->energyToDiffuse/sub[0]->area;
	Channels tmp1=sub[1]->shooter->energyToDiffuse/sub[1]->area;
	Channels e;
	if(sum(tmp0)<sum(tmp1))
	{
		e=tmp0;
		sub[0]->shooter->energyToDiffuse=Channels(0);
		sub[1]->shooter->energyToDiffuse-=e*sub[1]->area;
		assert(sum(sub[1]->shooter->energyToDiffuse)>-0.1);
		clampToZero(sub[1]->shooter->energyToDiffuse); // fix minor numerical errors
	} else {
		e=tmp1;
		sub[0]->shooter->energyToDiffuse-=e*sub[0]->area;
		assert(sum(sub[0]->shooter->energyToDiffuse)>-0.1);
		clampToZero(sub[0]->shooter->energyToDiffuse); // fix minor numerical errors
		sub[1]->shooter->energyToDiffuse=Channels(0);
	}
	assert(shooter);
	shooter->energyToDiffuse+=e*area;
	return e!=Channels(0);
	// v teto fci vznikala nepresnost, min sviticimu synovi s X odebral X+-chyba
	// oprava neeliminuje nepresnost u svitivejsiho syna, pouze zajisti aby min svitivy mel na konci energii 0
}

void Node::propagateEnergyUp()
{
	Node *node=parent;
	while(node && node->loadEnergyFromSubs()) node=node->parent;
}

#ifndef SUPPORT_DYNAMIC
Channels Node::getEnergyDynamic()
{
	return Channels(0);
}
#endif

real Node::accuracy()
{
	assert(shooter);
	return shooter->accuracy();
}

Channels Node::radiosityIndirect()
{
	Channels e=Channels(0);
	Node *node=parent;
	while(node)
	{
		e+=(node->energyDirect-node->sub[0]->energyDirect-node->sub[1]->energyDirect)/node->area;
		node=node->parent;
	}
	return e;
}

bool Node::check()
{
	assert(!(flags&FLAGS_CLUSTERING));
	assert(!shooter || !shooter->tmpFactor);
	assert(!shooter || sum(abs(shooter->energyToDiffuse))<1e10);
	return true;
}

bool Node::contains(Triangle *t)
{
	if(IS_TRIANGLE(this)) return this==t;
	if(IS_SUBTRIANGLE(this)) return false;
	return sub[0]->contains(t) || sub[1]->contains(t);
}

Node::~Node()
{
	assert(!sub[0]);
	assert(!sub[1]);
	if(shooter) delete shooter;
	__nodesAllocated--;
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// subtriangle, part of triangle

unsigned __subtrianglesAllocated=0;

SubTriangle::SubTriangle(SubTriangle *aparent,class Triangle *agrandpa) : Node(aparent,agrandpa)
{
	__subtrianglesAllocated++;
	subvertex=NULL;
#ifdef SUPPORT_LIGHTMAP
	if(grandpa) grandpa->subtriangles++;
#endif
	splitVertex_rightLeft=-2;//=dunno, ask somebody else
}

Point3 SubTriangle::to3d(Point2 a)
{
	return grandpa->to3d(a);
}

Point3 SubTriangle::to3d(int vertex)
// returns exact 3d coord where available
{
	assert(vertex>=0 && vertex<=2);
#ifdef IV_POINT
	// ivertex always returns the same 3d
	return ivertex(vertex)->point;
#else
	// subvertex shared by 2 triangles may return slightly different 3d for different triangles
	// may cause blackpixels in render
	return to3d(uv[vertex]);
#endif
}

Point3 SubTriangle::to3dlo(int vertex)
// returns approximate 3d coord (2d transformed to 3d)
{
	assert(vertex>=0 && vertex<=2);
	return to3d(uv[vertex]);
}

Point3 Triangle::to3d(int v)
{
	assert(v>=0 && v<=2);
	return *getVertex(v);
}

real SubTriangle::perimeter()
{
	return size(u2)+size(v2)+size(u2-v2);
}

SubTriangle *SubTriangle::brotherSub()
{
	assert(IS_SUBTRIANGLE(this));
	return SUBTRIANGLE(parent->sub[(this==parent->sub[0])?1:0]);
}

bool SubTriangle::isRight()
{
	bool result=v2==brotherSub()->u2;
	assert(result!=(u2==brotherSub()->v2));
	return result;
}

bool SubTriangle::isRightLeft()
{
	bool result=SUBTRIANGLE(sub[0])->v2==SUBTRIANGLE(sub[1])->u2;
	assert(result!=(SUBTRIANGLE(sub[1])->v2==SUBTRIANGLE(sub[0])->u2));
	return result;
}

#define MAGIC1  1.039618
#define MAGIC1b 1.10729
#define MAGIC2  1.96252

void (*__oraculum)()=NULL;

int SubTriangle::getSplitVertexSlow()
{
	// postara se o akcelerovany orakulum, cteni i psani
	if(ora_filling && !(flags&FLAG_IS_IN_ORA)) {ora_fill(&splitVertex_rightLeft);flags|=FLAG_IS_IN_ORA;}
	if(ora_reading && !(flags&FLAG_IS_IN_ORA)) {splitVertex_rightLeft=ora_read();flags|=FLAG_IS_IN_ORA;}
	// magicky nasobitel je tu proto aby pri shodne delce stran,
	// ktera nastava casto,
	// nedaval vinou zaokrouhlovacich chyb pokazde jine vysledky.

	#define IS_00(r) (fabs(r)<1)

	// zjisti result a jestli hrozi ze pokazdy vrati jinej vysledek
	bool danger=IS_00(size2(u2)-size2(v2)*MAGIC1);
	int result;
	if(size2(u2)>size2(v2)*MAGIC1)
	{
		danger=danger || IS_00(size2(u2-v2)-size2(u2)*MAGIC1);
		if(size2(u2-v2)>size2(u2)*MAGIC1)
			result=0;
		else
			result=2;
	}
	else
	{
		danger=danger || IS_00(size2(u2-v2)-size2(v2)*MAGIC1);
		if(size2(u2-v2)>size2(v2)*MAGIC1)
			result=0;
		else
			result=1;
	}

	// pokud je nebezpeci a nic neni v cache, zkusi to nahrat
	if(danger && __oraculum && splitVertex_rightLeft<0)
	{
		// doplni splitVertex_rightLeft vsude ve scene kde to jde
		//fprintf(stderr,"getSplitVertexSlow danger %i\n",(int)this);
		__oraculum();
		DBGLINE
		assert(splitVertex_rightLeft>=-2 && splitVertex_rightLeft<=5);
	}

	// pokud je neco v cache, pouzije to, ale overi ze se to shoduje
	// a kdyz ne tak bylo opravdu zdetekovano nebezpeci chyby
	if(splitVertex_rightLeft>=0)
	{
		assert(danger || result==splitVertex_rightLeft%3);
		result=splitVertex_rightLeft%3;
	}

	return result;
}

int SubTriangle::getSplitVertex()
{
	assert(sub[0]);
	assert(sub[1]);
	if(SUBTRIANGLE(sub[0])->uv[0]==uv[0]) return 0;
	if(SUBTRIANGLE(sub[0])->uv[0]==uv[1]) return 1;
	assert(SUBTRIANGLE(sub[0])->uv[0]==uv[2]);
	return 2;
}

void SubTriangle::splitGeometry(IVertex *asubvertex)
{
	if(sub[0]) return;

	// zjisti splitvertex
	// pokud nam nekdo prikazuje jakej pouzit, fce to vi a rekne nam to
	DBGLINE
	int rot=getSplitVertexSlow();
	DBGLINE

	// split the longest side, calculate splita and splitb
	// split line is { [u,v] | splita*u+splitb*v=1 }
	Point2 point=uv[rot];
	Vec2 splitvector=(uv[(rot+1)%3]+uv[(rot+2)%3])/2-uv[rot];
	real r=point.x*splitvector.y-point.y*splitvector.x;
	if(r>=0 && r<SMALL_REAL) r=SMALL_REAL; else
	if(r<=0 && r>-SMALL_REAL) r=-SMALL_REAL;

	// je nebezpeci ze spatne rozhodnem rightleft? pustme na to orakulum
	if(ABS(r)<0.001 && __oraculum && splitVertex_rightLeft<0)
	{
		//fprintf(stderr,"small r danger %i\n",(int)this);
		__oraculum();
		DBGLINE
	}

	// prikazuje nam nekdo kteryho syna dat doprava/doleva?
	if(splitVertex_rightLeft>=0)
	{
		bool rl=(splitVertex_rightLeft/3)!=0;
		if(rl && r<0)//prikazano rightleft ale r<0
		{
			assert(r>-0.01);
			r=SMALL_REAL;
		}
		else
		if(!rl && r>0)//prikazano leftright ale r>0
		{
			assert(r<0.01);
			r=-SMALL_REAL;
		}
	}
	// pokud nikdo neprikazoval a cache je prazdna, zaplnime ji,
	// orakulum neporadilo tak nevadi kdyz si to rozhodneme sami
	else
	{
		splitVertex_rightLeft=rot+(r>0?3:0);
	}
#ifdef LOG_LOADING_MES
	printf(" rot=%i rl=%i\n",rot,(r>0)?1:-1);
#endif

	DBGLINE
	splita=splitvector.y/r;
	splitb=-splitvector.x/r;
#ifdef HITS_FIXED
	assert(grandpa->u2.y==0);
	splitb=(grandpa->v2.y*splitb+grandpa->v2.x*splita)/HITS_UV_MAX;
	splita=grandpa->u2.x*splita/HITS_UV_MAX;
#endif
	// create subtriangles
	DBGLINE
	SubTriangle *sa=new SubTriangle(this,grandpa);
	DBGLINE
	sa->uv[0]=uv[rot];
	sa->uv[1]=uv[(rot+1)%3];
	sa->uv[2]=(uv[(rot+1)%3]+uv[(rot+2)%3])/2;
	sa->u2=sa->uv[1]-sa->uv[0];//sidevector1;
	sa->v2=sa->uv[2]-sa->uv[0];//splitvector;
	sa->area=area/2;
	sub[r<0?1:0]=sa;
	SubTriangle *sb=new SubTriangle(this,grandpa);
	sb->uv[0]=uv[rot];
	sb->uv[1]=sa->uv[2];//(uv[(rot+1)%3]+uv[(rot+2)%3])/2;
	sb->uv[2]=uv[(rot+2)%3];
	sb->u2=sb->uv[1]-sb->uv[0];//splitvector;
	sb->v2=sb->uv[2]-sb->uv[0];//sidevector2;
	sb->area=area/2;
	sub[r<0?0:1]=sb;
	// create subvertex
	DBGLINE
	createSubvertex(asubvertex,rot);
	DBGLINE
}

#ifndef ONLY_PLAYER

void SubTriangle::splitHits(Hits* phits,Hits *phits2)
{
	assert(sub[0]);
	assert(phits);
	assert(phits2);
	assert(!phits2->hits);
	unsigned old_hits=phits->hits;
	phits->reset();
	for(unsigned i=0;i<old_hits;i++)
	{
		bool first=phits->hit[i].u*splita+phits->hit[i].v*splitb>1;
		((!first)?phits:phits2)->insert(phits->hit[i]);
	}
}

bool SubTriangle::wishesToSplitReflector()
{
	assert(shooter);
	if(!sub[0]) return false;//dal uz splitovat nejde
	if(sub[0]->shooter) return false;//uz je splitnutej
	real e0=sum(sub[0]->energyDirect);
	real e1=sum(sub[1]->energyDirect);
	real esum=ABS(e0)+ABS(e1);
	real edif=fabs(e0-e1);
	return edif>esum/REFLECTOR_MESHING;
}

#endif

SubTriangle::~SubTriangle()
{
	if(sub[0])
	{
		delete SUBTRIANGLE(sub[0]);
		delete SUBTRIANGLE(sub[1]);
		sub[0]=NULL;
		sub[1]=NULL;
	}
	for(int i=0;i<3;i++)
	{
		IVertex *iv=ivertex(i);
		if(iv) iv->remove(this,false);
	}
#ifdef SUPPORT_LIGHTMAP
	if(grandpa) grandpa->subtriangles--;
#endif
	__subtrianglesAllocated--;
}

//////////////////////////////////////////////////////////////////////////////
//
// lightmap

#ifdef SUPPORT_LIGHTMAP

unsigned __lightmapsAllocated=0;

Lightmap::Lightmap()
{
	w=0;
	h=0;
	bitmap=NULL;
	isClean=true;
}

void Lightmap::setSize(unsigned aw,unsigned ah)
{
	if(w==aw && h==ah) return;
	__lightmapsAllocated-=w*h;
	delete[] bitmap;
	w=aw;
	h=ah;
	if(!aw||!ah) bitmap=NULL; else bitmap=new byte[w*h];
	memset(bitmap,0,w*h);
	__lightmapsAllocated+=w*h;
	isClean=true;
}

void Lightmap::Save(char *name)
{
#ifdef SUPPORT_PNG
 png_struct *png_ptr; png_info *info_ptr;
 png_byte **row_pointers; unsigned i;

 FILE *png_file=fopen(name,"wb");

 png_ptr=png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL);
 info_ptr=png_create_info_struct(png_ptr);

 setjmp(png_jmpbuf(png_ptr));

 png_init_io(png_ptr,png_file);
 png_set_IHDR(png_ptr,info_ptr,w,h,8,PNG_COLOR_TYPE_GRAY,
 PNG_INTERLACE_NONE,PNG_COMPRESSION_TYPE_BASE,PNG_FILTER_TYPE_BASE);

 png_write_info(png_ptr,info_ptr);

 row_pointers=(png_byte **)malloc(h*sizeof(png_byte*));
 row_pointers[0]=bitmap;

 for (i=1;i<h;i++) row_pointers[i]=row_pointers[i-1]+w;

 png_write_image(png_ptr,row_pointers);
 png_write_end(png_ptr,info_ptr);
 png_destroy_write_struct(&png_ptr,(png_infopp) NULL);

 fclose(png_file); free(row_pointers);
#endif
}

Lightmap::~Lightmap()
{
	delete[] bitmap;
	__lightmapsAllocated-=w*h;
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// triangle, part of cluster and object

unsigned __trianglesAllocated=0;
unsigned __trianglesWithBadNormal=0;

Triangle::Triangle() : SubTriangle(NULL,this)
{
	__trianglesAllocated++;
#ifdef SUPPORT_LIGHTMAP
	subtriangles=0;
#endif
	topivertex[0]=NULL;
	topivertex[1]=NULL;
	topivertex[2]=NULL;
	edge[0]=NULL;
	edge[1]=NULL;
	edge[2]=NULL;
	isInCluster=0;
	area=0;       // says that setGeometry wasn't called yet
	surface=NULL; // says that setSurface wasn't called yet
}

static real spicatost(real a,real b,real c) // delky stran
{
	real lo=MIN(a,MIN(b,c));
	real hi=MAX(a,MAX(b,c));
	real mid=a+b+c-lo-hi;
	return (lo+mid-hi<=0)?1e10f:(hi/(lo+mid-hi)); // spicatost, 1..1000 pohoda, 1000..nekonecno jehla
}

// calculates triangle area from triangle vertices
real calculateArea(Vec3 v0, Vec3 v1, Vec3 v2)
{
	real a=size2(v1-v0);
	real b=size2(v2-v0);
	real c=size2(v2-v1);
	return sqrt(2*b*c+2*c*a+2*a*b-a*a-b*b-c*c)/4;
}

// rots muze prikazat kolikrat zarotovat, -1=autodetekce
// vraci kolikrat zarotoval, -1..-11=vadna geometrie, zahodit
// n=NULL .. spocita normalu sam
// n!=NULL .. pouzije zadanou normalu, nicmene SUPPORT_DYNAMIC pri transformacich stejne zada NULL a stara je zahozena, spocita se nova
//
// Objekt muze byt scalovany. a/b/c ale dostavame v objectspace a tak musi zustat.
// Pokud ale nevyscalujeme area, bude pri distribuci vznikat/zanikat energie.
// obj2world tedy pouzijeme pouze k vypoctu area ve worldspace.

S8 Triangle::setGeometry(Vec3 *a,Vec3 *b,Vec3* c,const Matrix *obj2world,Normal *n,int rots)
{
	isValid=0;
	assert(rots>=-1 && rots<=2);
	if(rots==-1) rotations=0; else rotations=rots;

again:
	assert(rotations<=2);

	qvertex[(3-rotations)%3]=a;
	qvertex[(4-rotations)%3]=b;
	qvertex[(5-rotations)%3]=c;

	// set u3,v3,n3
	qn3=normalized(ortogonalTo(getR3(),getL3()));
	qn3.d=-dot(getS3(),getN3());
	if(!IS_VEC3(getN3())) return -3; // throw out degenerated triangle
	qu3=normalized(getR3());
	qv3=ortogonalTo(getN3(),getU3());
	if(!IS_VEC3(getV3())) return -10; // throw out degenerated triangle

	// set s2,u2,v2
	real rsize=size(getR3());
	real lsize=size(getL3());
	if(rsize<=0 || lsize<=0) return -1; // throw out degenerated triangle
	real psqr=size2(getU3()-(getL3()/lsize));// ctverec nad preponou pri jednotkovejch stranach
	#ifdef ALLOW_DEGENS
	if(psqr<=0) {psqr=0.0001f;printf("Low numerical quality, fixing area=0 triangle.\n");} else
	if(psqr>=4) {psqr=3.9999f;printf("Low numerical quality, fixing area=0 triangle.\n");}
	#endif
	real cosa=1-psqr/2;
	real sina=sqrt(psqr*(1-psqr/4));//sin(acos(cosa)); //first is probably faster
	uv[0]=Vec2(0,0);
	uv[1]=u2=Vec2(rsize,0);
	uv[2]=v2=Vec2(cosa,sina)*lsize;
	area=sina/2*rsize*lsize;
	if(psqr<=0) return -7;
	if(psqr>=4) return -9;
	if(1-psqr/4<=0) return -8;
	if(sina<=0) return -6;
	if(area<=0) return -4;
	if(area<=SMALL_REAL) return -5;
	//assert(size(SubTriangle::to3d(2)-*vertex[2])<0.001);

	// stary rotace davajici ruzny vysledky s a bez optimalizaci
	//if(v2.x<0) setGeometry(b,c,a);// to avoid negative coordinates
	//if(v2.y>MAX(u2.x,v2.x)) setGeometry(b,c,a);// to avoid high lightmaps like 512*1000000
	//if(v3!.x>v2.x) setGeometry(b,c,a);// aby byl horni vrchol uprostred a ne vyklonenej doprava

	// triangly s uhlem alfa vetsim nez nakejch 89 stupnu zarotuje.
	// kdybych vzal jako hranici 90 stupnu, vinou zaokrouhlovacich chyb
	//  bych tentyz pravy uhel nekdy rotoval a nekdy ne.
	//  uhly presne kolem nejakych 89 stupnu se nastesti nevyskytuji.
	if(rots==-1 && // tohle delej jen pri autodetekci rotaci
	   psqr>MAGIC2 || // to avoid negative coordinates
	// triangly vyssi nez sirsi zarotuje aby byly radsi sirsi.
	// ze stejnych duvodu opet ne presne vyssi ale o velice magicky nasobek.
	   v2.y>MAGIC1b*MAX(u2.x,v2.x))// to avoid high lightmaps like 512*1000000
	{
		// zarotuje
		rotations++;
		goto again;
	}
	// kdyz ma prikazany pocet rotaci, overi ze rozdil od ocekavani
	// neni vetsi nez co by se do zaokrouhlovaci chyby veslo
	if(rots!=-1)
	{
		#define MAXERR 0.01
		assert(psqr>MAGIC2-MAXERR);
		assert(v2.y>MAGIC1b*MAX(u2.x,v2.x)-MAXERR);
		#undef MAXERR
	}

	if(u2.x<0 || u2.y!=0 || v2.x<0 || v2.y<0) return -2; // throw out degenerated triangle
	assert(u2.x>=0);
	assert(u2.y==0);
	assert(v2.x>=0);
	assert(v2.y>=0);

	isNeedle = (RRGetState(RRSS_FIGHT_NEEDLES) && spicatost(lsize,rsize,size(getL3()-getR3()))>1000) ? 1 : 0;

	// prepocitat area v worldspace
	area = calculateArea(a->transformed(obj2world),b->transformed(obj2world),c->transformed(obj2world));
	if(!IS_NUMBER(area)) return -11;

	assert(IS_VEC3(getV3()));
	isValid=1;
	return rotations;
}

char Scene::selectColorFilter(int i, const real *rgb)
{
	assert(i>=0 && i<4);
	// selects color component for further calculations
	// you must resetStaticIllumination() and distribute() to get
	//  static illumination for new filter
	RRColor myColorFilter[4]={{1,0,0},{0,1,0},{0,0,1},{0.33f,0.33f,0.33f}};
	char myColorID[4]={'r','g','b','w'};
	__colorFilter[0]=rgb?rgb[0]:myColorFilter[i][0];
	__colorFilter[1]=rgb?rgb[1]:myColorFilter[i][1];
	__colorFilter[2]=rgb?rgb[2]:myColorFilter[i][2];

	// adjusts diffuseReflectance in all surfaces (faster than fixing all usages of diffuseReflectance)
	//  to reflect only selected component (blue material to reflect only blue)
	for(unsigned j=0;j<surfaces;j++)
	{
	  RRSurface *s=&surface[j];
	  real r=s->diffuseReflectanceColor[0];
	  real g=s->diffuseReflectanceColor[1];
	  real b=s->diffuseReflectanceColor[2];
//        s->diffuseReflectance=s->_rd*(__colorFilter[0]*s->_rdcx+__colorFilter[1]*s->_rdcy+__colorFilter[2]*(1-s->_rdcx-s->_rdcy));
	  s->diffuseReflectance=s->_rd*(__colorFilter[0]*r+__colorFilter[1]*g+__colorFilter[2]*b)/(PHOTOMETRIC_R*r+PHOTOMETRIC_G*g+PHOTOMETRIC_B*b+0.001f);
	}

	return myColorID[i];
}

int Scene::turnLight(int whichLight,real intensity)
{
	int light=0;
	for(unsigned s=0;s<surfaces;s++)
		if(surface[s]._ed>0)
		{
			if(light==whichLight) surface[s].diffuseEmittance=surface[s]._ed*intensity;
			light++;
		}
	return light;
}

Channels Triangle::setSurface(RRSurface *s, const Vec3& additionalRadiantExitance)
{
	assert(area!=0);//setGeometry must be called before setSurface
	assert(s);
	surface=s;
#if CHANNELS == 1
	real r=surface->diffuseEmittanceColor[0];
	real g=surface->diffuseEmittanceColor[1];
	real b=surface->diffuseEmittanceColor[2];
	real filteringCoef=(__colorFilter[0]*r+__colorFilter[1]*g+__colorFilter[2]*b)/(PHOTOMETRIC_R*r+PHOTOMETRIC_G*g+PHOTOMETRIC_B*b+0.01f);
	Channels e=area * ( filteringCoef*surface->diffuseEmittance
	  + __colorFilter[0]*additionalRadiantExitance.x+__colorFilter[1]*additionalRadiantExitance.y+__colorFilter[2]*additionalRadiantExitance.z );
	assert(add>=0);
	assert(filteringCoef>=0);
	assert(e>=0);
#else
	Channels e=*(Vec3*)__colorFilter * area *
	  ( *(Vec3*)surface->diffuseEmittanceColor * surface->diffuseEmittance + additionalRadiantExitance );
#endif
	assert(surface->diffuseEmittance>=0);
	assert(area>=0);
	assert(additionalRadiantExitance.x>=0);
	assert(additionalRadiantExitance.y>=0);
	assert(additionalRadiantExitance.z>=0);
#ifndef ONLY_PLAYER
	// load triangle shooter with energy emited by surface
	assert(shooter);
	shooter->energyToDiffuse=e;
	// load received energy accumulator
	energyDirect=e;
	sourceEnergy=e;
#endif
	return e;
}

Point3 Triangle::to3d(Point2 a)
{
	return getS3()+getU3()*a.x+getV3()*a.y;
}

void Triangle::compact()
{
#ifndef ONLY_PLAYER
	hits.compact();
#endif
}

Triangle::~Triangle()
{
	// iv_forEach()
	// ze vsech ivertexu v trianglu ostranit trianglovy cornery
	// prazdny ivertexy odstranit
	// subtriangly zrusit...
	__trianglesAllocated--;
}

//////////////////////////////////////////////////////////////////////////////
//
// reflectors (light sources and things that reflect light)

#ifndef ONLY_PLAYER

Reflectors::Reflectors()
{
	nodesAllocated=0;
	node=NULL;
	nodes=0;
	reset();
}

void Reflectors::reset()
{
	for(int i=nodes;i--;) remove(i);
	nodes=0;
	bests=0;
}

bool Reflectors::insert(Node *anode)
{
	if(anode->flags&FLAG_IS_REFLECTOR) return false;
	if(anode->shooter->energyDiffused==Channels(0) && anode->shooter->energyToDiffuse==Channels(0)) return false;
	if(!nodesAllocated)
	{
		nodesAllocated=1024;
		node=(Node **)malloc(nodesAllocated*sizeof(Node *));
	}
	else
	if(nodes==nodesAllocated)
	{
		size_t oldsize=nodesAllocated*sizeof(Node *);
		nodesAllocated*=4;
		node=(Node **)realloc(node,oldsize,nodesAllocated*sizeof(Node *));
	}
	anode->flags|=FLAG_IS_REFLECTOR;
	node[nodes++]=anode;
	return true;
}

void Reflectors::remove(unsigned n)
{
	assert(node[n]->flags&FLAG_IS_REFLECTOR);
	node[n]->flags&=~FLAG_IS_REFLECTOR;
	node[n]=node[--nodes];
	bests=0; // invalidate best cache
}

void Reflectors::insertObject(Object *o)
{
	for(unsigned i=0;i<o->triangles;i++) insert(&o->triangle[i]);
	for(unsigned i=0;i<o->clusters;i++) insert(&o->cluster[i]);
}

void Reflectors::removeObject(Object *o)
{
	for(int i=nodes-1;i>=0;i--)
		if(o->contains(node[i])) remove(i);
}

void Reflectors::removeSubtriangles()
{
	for(int i=nodes;i--;)
		if(IS_SUBTRIANGLE(node[i])) remove(i);
}

bool Reflectors::check()
{
	for(unsigned i=0;i<nodes;i++) if(node[i]->shooter)
	{
		assert(IS_CHANNELS(node[i]->shooter->energyToDiffuse));
	}
	return true;
}

Node *Reflectors::best(bool distributing,real avgAccuracy,real improveBig,real improveInaccurate)
{
	DBGLINE
	// if cache empty, fill cache
	if(!bests && nodes)
	{
		// search reflector with low accuracy, high energyToDiffuse etc
		real bestQ[BESTS];
		for(unsigned i=0;i<nodes;i++) if(node[i]->shooter)
		{
			// calculate q for node
			real toDiffuse=sum(abs(node[i]->shooter->energyToDiffuse));
			real q;

			if(distributing) {
			  // when only diffusing (not improving factors), use simpler criteria
			  q=toDiffuse;
			} else {
			  real allEnergy=sum(abs(node[i]->shooter->energyToDiffuse+node[i]->shooter->energyDiffused));
			  #define DISTRIB_TIME 1 // cost of energy redistribution
			  #define REFRESH_TIME 10 // cost of form factor recalculation
			  real distribValue=toDiffuse/(node[i]->shooter->factors()+0.5f)*DISTRIB_TIME;
			  real refreshValue=allEnergy/(node[i]->shooter->shotsForFactors+0.5f)*REFRESH_TIME;
			  q=distribValue+refreshValue;
			  //fprintf(stderr,".%i(%f,%f,%f,%f).",(int)node[i],toDiffuse,allEnergy,distribValue,refreshValue);
			}

			// sort [q,node] into best cache
			unsigned pos=bests;
			while(pos>0 && bestQ[pos-1]<q)
			{
			  if(pos<BESTS)
			  {
			    bestNode[pos]=bestNode[pos-1];
			    bestQ[pos]=bestQ[pos-1];
			  }
			  pos--;
			}
			if(pos<BESTS)
			{
			  bestNode[pos]=node[i];
			  bestQ[pos]=q;
			  if(bests<BESTS) bests++;
			}
		}
	}
	// get best from cache
	if(!bests) return NULL;
	Node *best=bestNode[0];
	bests--;
	for(unsigned i=0;i<bests;i++) bestNode[i]=bestNode[i+1];
	assert(best);
	// possibly split best
	if(!IS_CLUSTER(best) && SUBTRIANGLE(best)->wishesToSplitReflector())
	{
		assert(!best->sub[0]->shooter);
		assert(!best->sub[1]->shooter);
		best->sub[0]->shooter=new Shooter();
		best->sub[1]->shooter=new Shooter();
		insert(best->sub[0]);
		insert(best->sub[1]);
	}
	return best;
}

struct NodeQ 
{
	Node* node; 
	real q;
};

int CompareNodeQ(const void* elem1, const void* elem2)
{
	return (((NodeQ*)elem2)->q < ((NodeQ*)elem1)->q) ? -1 : 1;
}

bool Reflectors::findFactorsTo(Node *n)
{
	for(unsigned i=0;i<nodes;i++)
	{
		assert(node[i]->shooter);
		real pwr=node[i]->shooter->contains(n);
		if(pwr!=-1)
			printf("[%x %f]",(unsigned)(intptr_t)node[i],pwr);
	}
	printf(" ");
	return false;
}

Reflectors::~Reflectors()
{
	if(node) free(node);
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// set of triangles

Triangles::Triangles()
{
	trianglesAllocated=8;
	triangle=(Triangle **)malloc(trianglesAllocated*sizeof(Triangle *));
	reset();
}

void Triangles::reset()
{
	triangles=0;
	trianglesAfterResurrection=0;//pro jistotu
}

void Triangles::insert(Triangle *key)
{
	if(triangles==trianglesAllocated)
	{
		size_t oldsize=trianglesAllocated*sizeof(Triangle *);
		trianglesAllocated*=2;
		triangle=(Triangle **)realloc(triangle,oldsize,trianglesAllocated*sizeof(Triangle *));
	}
	triangle[triangles++]=key;
}

//removes triangle from set

Triangle *Triangles::get()
{
	if(!triangles) return NULL;
//        if(!trianglesAfterResurrection) trianglesAfterResurrection=triangles;
	triangles--;
	return triangle[triangles];
}

// doesn't remove triangle from set

Triangle *Triangles::get(real a)
{
	assert(triangles>0);
	unsigned t=0;
	while(a>triangle[t]->area)
	{
		a-=triangle[t]->area;
		t++;
		assert(t<triangles);
	}
	return triangle[t];
}

void Triangles::forEach(void (*func)(Triangle *key,va_list ap),...)
{
	va_list ap;
	va_start(ap,func);
	for(unsigned i=0;i<triangles;i++) func(triangle[i],ap);
	va_end(ap);
}

void Triangles::holdAmulet()
{
	trianglesAfterResurrection=triangles;
}

void Triangles::resurrect()
{
	triangles=trianglesAfterResurrection;
	trianglesAfterResurrection=0;
}

Triangles::~Triangles()
{
	free(triangle);
}

//////////////////////////////////////////////////////////////////////////////
//
// set of edges

unsigned __edgesAllocated=0;

Edges::Edges()
{
	edgesAllocated=4;
	edge=(Edge **)malloc(edgesAllocated*sizeof(Edge *));
	reset();
	__edgesAllocated+=edgesAllocated;
}

void Edges::reset()
{
	edges=0;
}

void Edges::insert(Edge *key)
{
	if(edges==edgesAllocated)
	{
		__edgesAllocated+=7*edgesAllocated;
		size_t oldsize=edgesAllocated*sizeof(Edge *);
		edgesAllocated*=8;
		edge=(Edge **)realloc(edge,oldsize,edgesAllocated*sizeof(Edge *));
	}
	edge[edges++]=key;
}

Edge *Edges::get()
{
	assert(edges>0);
	edges--;
	return edge[edges];
}

Edges::~Edges()
{
	if(edgesAllocated) free(edge);
	__edgesAllocated-=edgesAllocated;
}

//////////////////////////////////////////////////////////////////////////////
//
// cluster, set of triangles, part of object

#ifndef ONLY_PLAYER

unsigned __clustersAllocated=0;

Cluster::Cluster() : Node(NULL,NULL)
{
	area=0;
	__clustersAllocated++;
}

void SubTriangle::makeDirty()
{
	for(int i=0;i<3;i++)
	{
		IVertex *v=ivertex(i);
		assert(v);
		v->makeDirty();
	}
	flags|=FLAG_DIRTY_ALL_SUBNODES;
}

void Cluster::makeDirty()
{
	assert(sub[0]);
	if(IS_CLUSTER(sub[0])) CLUSTER(sub[0])->makeDirty(); else SUBTRIANGLE(sub[0])->makeDirty();
	if(IS_CLUSTER(sub[1])) CLUSTER(sub[1])->makeDirty(); else SUBTRIANGLE(sub[1])->makeDirty();
}

void Cluster::insert(Triangle *t,Triangles *triangles)
{
	if(t->isInCluster) return;
	t->isInCluster=1;
	assert(!t->parent);
	triangles->insert(t);
	assert(!t->topivertex[0]); // buildTopIVertices can't go before buildClusters
	assert(!t->topivertex[1]); // (why?)
	assert(!t->topivertex[2]);
}

void insertFreeNeighboursTo(Triangle *triangle,va_list ap)
{
	Cluster *cluster=va_arg(ap,Cluster *);
	Triangles *triangles=va_arg(ap,Triangles *);
	int *edges=va_arg(ap,int *);

	for(int e1=0;e1<3;e1++)
	{
		Edge *e=triangle->edge[e1];
		if(e && e->free)
		{
			(*edges)++;
			e->free=false;
			cluster->insert(e->triangle[0],triangles);
			cluster->insert(e->triangle[1],triangles);
		}
	}
}

real findMostDistantPoints(Point3 *p,unsigned points,unsigned *far1,unsigned *far2)
{
	assert(points>=2);
	for(unsigned i=0;i<points;i++) assert(IS_VEC3(p[i]));
	real maxdist=-1;
	for(unsigned i=0;i<points-1;i++)
	  for(unsigned j=i+1;j<points;j++)
	  {
	    real dist=size2(p[i]-p[j]);
	    assert(dist>=0);
	    if(dist>maxdist)
	    {
	      maxdist=dist;
	      *far1=i;
	      *far2=j;
	    }
	  }
	assert(maxdist>=0);
	return sqrt(maxdist);
}

Node *Triangles::buildClusterHierarchy(bool differentNormals,Cluster *aparent,Cluster *cluster,unsigned *c,unsigned maxc)
{
	// build cluster hierarchy
	// -> sekat aby mel rez co nejvetsi angly a neshody v diffuseEmittance (50%)
	//    vysledny clustery mely co nejpodobnejsi plochu (30%)
	//    rez byl co nejkratsi (20%)
	// -> nelze efektivne implementovat
	//    nicmoc pokus s radou problemu (napr u torusu) je hladovej algac: najdi nejvetsi angle a pripojuj nejvetsi ze sousednich
	// -> jiny, implementovatelny algac:
	//    0. ma-li 1 triangl, nebuilduj cluster ale vrat triangl
	//    1. kdykoliv obsahuje prilis ruznorody normaly (rozdil>=PI/4), vybrat rovinu (dospecifikovat; !aby blbe nefik kostku) a rozseknout na 2 clustery podle ni
	//    2. kdykoliv obsahuje nesouvisly oblasti, rozdelit je do 2 clusteru
	//    3. vybrat rovinu (kolmou na spoj nejvzdalenejsich vertexu) a rozseknout na 2 clustery podle ni

	for(unsigned i=0;i<triangles;i++) assert(IS_VEC3(triangle[i]->getN3()));

	// 0. if triangles==1, skip building and return triangle
	assert(triangles>0);
	if(triangles==1)
	{
		assert(!triangle[0]->parent);
		triangle[0]->parent=aparent;
		return triangle[0];
	}
	Cluster *thisCluster=&cluster[*c];
	thisCluster->parent=aparent;
	assert(thisCluster->shooter);
	//thisCluster->shooter=new Shooter;
	assert(*c<maxc);
	(*c)++;

	// 1. if normals are too different, select plane and split
	if(differentNormals)/**/
	{
		Point3 *norm=new Point3[triangles];
		for(unsigned i=0;i<triangles;i++) norm[i]=triangle[i]->getN3();
		unsigned t0;
		unsigned t1;
		for(unsigned i=0;i<triangles;i++) assert(IS_VEC3(norm[i]));
		findMostDistantPoints(norm,triangles,&t0,&t1);
		assert(t0<triangles);
		assert(t1<triangles);
		Angle angle=angleBetweenNormalized(norm[t0],norm[t1]);
		if(angle>MAX_CLUSTER_ANGLE_S)
		{
			Triangles tri0;
			Triangles tri1;
			for(unsigned t=0;t<triangles;t++)
				((size2(norm[t]-norm[t0])<size2(norm[t]-norm[t1]))?tri0:tri1).insert(triangle[t]);
			assert(tri0.triangles>0);
			assert(tri1.triangles>0);
			thisCluster->sub[0]=tri0.buildClusterHierarchy(true,thisCluster,cluster,c,maxc);
			thisCluster->sub[1]=tri1.buildClusterHierarchy(true,thisCluster,cluster,c,maxc);
			//thisCluster->sub[0]->parent=this;
			//thisCluster->sub[1]->parent=this;
			assert(thisCluster->area==0);
			thisCluster->area=thisCluster->sub[0]->area+thisCluster->sub[1]->area;

			// propagate energy to higher levels
			thisCluster->loadEnergyFromSubs();
			return thisCluster;
		}
		delete[] norm;
	}

	// 2. if cluster has more areas, split cluster

	// 3. find most distant vertices, select plane between them and split
	Point3 *mid=new Point3[triangles];
	for(unsigned i=0;i<triangles;i++)
	{
		assert(triangle[i]);
		//mid[i]=*(triangle[i]->vertex[0])+*(triangle[i]->vertex[1])+*(triangle[i]->vertex[2]);
		Triangle *t=triangle[i];
		mid[i]=*t->getVertex(0)+*t->getVertex(1)+*t->getVertex(2);
		assert(IS_VEC3(mid[i]));
	}
//  for(unsigned i=0;i<triangles;i++) printf("mid[%i]= %f %f %f\n",i,(double)mid[i].x,(double)mid[i].y,(double)mid[i].z);
	unsigned t0;
	unsigned t1;
	findMostDistantPoints(mid,triangles,&t0,&t1);
	assert(t0>=0 && t0<triangles);
	assert(t1>=0 && t1<triangles);
	Triangles tri0;
	Triangles tri1;
	for(unsigned t=0;t<triangles;t++)
		((size2(mid[t]-mid[t0])<size2(mid[t]-mid[t1]))?tri0:tri1).insert(triangle[t]);
//printf("splitting cluster %i -> %i + %i\n",triangles,tri0.triangles,tri1.triangles);
//GETCH;
	assert(tri0.triangles>0);
	assert(tri1.triangles>0);
	thisCluster->sub[0]=tri0.buildClusterHierarchy(false,thisCluster,cluster,c,maxc);
	thisCluster->sub[1]=tri1.buildClusterHierarchy(false,thisCluster,cluster,c,maxc);
	assert(thisCluster->sub[0]->parent==thisCluster);
	assert(thisCluster->sub[1]->parent==thisCluster);
	assert(thisCluster->area==0);
	thisCluster->area=thisCluster->sub[0]->area+thisCluster->sub[1]->area;

	// propagate energy to higher levels
	thisCluster->loadEnergyFromSubs();
		delete[] mid;
	return thisCluster;
}

int Cluster::buildAround(Edge *e,Cluster *cluster,unsigned *c,unsigned maxc)
{
	assert(this==&cluster[*c]);
	Triangles triangles;
	int edges=1;
	e->free=false;
	insert(e->triangle[0],&triangles);
	insert(e->triangle[1],&triangles);
	triangles.forEach(insertFreeNeighboursTo,this,&triangles,&edges);
	triangles.buildClusterHierarchy(true,NULL,cluster,c,maxc);
	return edges;
}

Triangle *Cluster::getTriangle(real a)
{
	assert(sub[0]);
	if(a<sub[0]->area)
	{
		if(!IS_CLUSTER(sub[0])) return TRIANGLE(sub[0]);
		return CLUSTER(sub[0])->getTriangle(a);
	}
	if(!IS_CLUSTER(sub[1])) return TRIANGLE(sub[1]);
	return CLUSTER(sub[1])->getTriangle(a-sub[0]->area);
}

Triangle *Cluster::randomTriangle()
{
	return getTriangle(rand()*area/RAND_MAX);
}

Cluster::~Cluster()
{
//!	for(unsigned t=0;t<triangles;t++)
//!		triangle[t]->removeFromIVertices(this);
	if(parent) parent->sub[(parent->sub[0]==this)?0:1]=NULL;
	//removeFromIVertices(this);
	if(sub[0])
	{
		sub[0]->parent=NULL;
		sub[0]=NULL;
	}
	if(sub[1])
	{
		sub[1]->parent=NULL;
		sub[1]=NULL;
	}
	__clustersAllocated--;
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// object, part of scene

Object::Object(int avertices,int atriangles)
{
	vertices=avertices;
	triangles=atriangles;
	edges=0;
	triangle=new Triangle[triangles];
	edge=NULL;
#ifndef ONLY_PLAYER
	clusters=0;
	cluster=NULL;
	bound.center=Point3(0,0,0);
	bound.radius=BIG_REAL;
	bound.radius2=BIG_REAL;
	energyEmited=Channels(0);
#endif
#ifdef SUPPORT_TRANSFORMS
	transformMatrix=NULL;
	inverseMatrix=NULL;
	matrixDirty=false;
	for(unsigned t=0;t<triangles;t++) triangle[t].object=this;
#endif
#ifdef SUPPORT_DYNAMIC
	trianglesEmiting=0;
#endif
	vertexIVertex=new IVertex*[vertices];
	memset(vertexIVertex,0,sizeof(void*)*vertices);
	IVertexPool=NULL;
	IVertexPoolItems=0;
	IVertexPoolItemsUsed=0;
}

Channels Object::getVertexRadiosity(unsigned avertex)
{
	assert(avertex<vertices);
	assert(vertexIVertex[avertex]);
	return vertexIVertex[avertex]->exitance();
}

void addEdgeWith(Triangle *t1,va_list ap)
{
	Triangle *t2      =va_arg(ap,Triangle *);
	Edge     *edge    =va_arg(ap,Edge *);
	unsigned *edges   =va_arg(ap,unsigned *);
	unsigned maxedges =va_arg(ap,unsigned);

	for(unsigned v1=0;v1<3;v1++)
	  if(!t1->edge[v1])
	    for(unsigned v2=0;v2<3;v2++)
	      if(!t2->edge[v2] &&
	         t1->getVertex(v1)==t2->getVertex((v2+1)%3) &&
	         t1->getVertex((v1+1)%3)==t2->getVertex(v2))
	{
		Angle angle=angleBetweenNormalized(t1->getN3(),t2->getN3());
		if(angle<MAX(MAX_CLUSTER_ANGLE_B,MAX_INTERPOL_ANGLE))
		{
		  assert(*edges<maxedges);
		  if(*edges>=maxedges)
		  {
		    printf("# More edges than expected, throwing out.\n");
		    return;
		  }
		  edge[*edges].angle=angle;
		  edge[*edges].interpol=INTERPOL_BETWEEN_A(t1,t2,angle);
		  edge[*edges].vertex[0]=t1->getVertex(v1);
		  edge[*edges].vertex[1]=t1->getVertex((v1+1)%3);
		  edge[*edges].triangle[0]=t1;
		  edge[*edges].triangle[1]=t2;
		  assert(!t1->edge[v1]);
		  assert(!t2->edge[v2]);
		  t1->edge[v1]=&edge[*edges];
		  t2->edge[v2]=&edge[*edges];
		  (*edges)++;
		}
	}
}

void Object::buildEdges()
{
	assert(!edge);

	edge=new Edge[triangles*3/2];
	for(unsigned t=0;t<triangles;t++)
	{
		triangle[t].edge[0]=NULL;
		triangle[t].edge[1]=NULL;
		triangle[t].edge[2]=NULL;
	}
	Triangles *trianglesInV=new Triangles[vertices];
	for(unsigned t=0;t<triangles;t++)
		for(int v1=0;v1<3;v1++)
		{
			unsigned ve[3];
			importer->getTriangle(t,ve[0],ve[1],ve[2]);
			unsigned v = ve[(v1+triangle[t].rotations)%3];
			assert(v>=0 && v<vertices); //v musi byt vertexem tohoto objektu
			trianglesInV[v].insert(&triangle[t]);
		}
	for(unsigned v=0;v<vertices;v++)
	{
		Triangle *tri;
		while((tri=trianglesInV[v].get()))
		{
			trianglesInV[v].forEach(addEdgeWith,tri,edge,&edges,(unsigned)(triangles*3/2));
		}
	}
	delete[] trianglesInV;
}

Object::~Object()
{
	check();
	delete intersector;
#ifndef ONLY_PLAYER
	if(cluster) delete[] cluster;
#endif
	delete[] triangle;
	if(edge) delete[] edge;
	delete[] vertexIVertex;
	deleteIVertices();
}

#ifndef ONLY_PLAYER

// uvede energie v objektu do stavu po nacteni sceny
// akceptuje upravene surfacy

void Object::resetStaticIllumination()
{
	// smaze akumulatory (ale necha jim flag zda jsou v reflectors)
	for(unsigned c=0;c<clusters;c++) {U8 flag=cluster[c].flags&FLAG_IS_REFLECTOR;cluster[c].reset();cluster[c].flags=flag;}
	for(unsigned t=0;t<triangles;t++) {U8 flag=triangle[t].flags&FLAG_IS_REFLECTOR;triangle[t].reset();triangle[t].flags=flag;}
	// nastavi akumulatory na pocatecni hodnoty
	energyEmited=Channels(0);
	for(unsigned t=0;t<triangles;t++) if(triangle[t].surface) 
	{
		const real* addExitingFlux=importer->getTriangleAdditionalRadiantExitingFlux(t);
		const real* addExitance=importer->getTriangleAdditionalRadiantExitance(t);
		Vec3 sumExitance=(addExitance?*(Vec3*)addExitance:Vec3(0,0,0)) + (addExitingFlux?*(Vec3*)addExitingFlux/triangle[t].area:Vec3(0,0,0));
		energyEmited+=abs(triangle[t].setSurface(triangle[t].surface,sumExitance));
	}
	for(unsigned t=0;t<triangles;t++) if(triangle[t].surface) triangle[t].propagateEnergyUp();
}

void Object::updateMatrices()
{
	// updatne matice
#ifdef SUPPORT_TRANSFORMS
	transformMatrix=(Matrix*)importer->getWorldMatrix();
	inverseMatrix=(Matrix*)importer->getInvWorldMatrix();
	// vyzada si prvni transformaci
	matrixDirty=true;
#endif
}

bool Object::contains(Triangle *t)
{
	return (t>=&triangle[0]) && (t<&triangle[triangles]);
}

bool Object::contains(Cluster *c)
{
	return (c>=&cluster[0]) && (c<&cluster[clusters]);
}

bool Object::contains(Node *n)
{
	return (IS_CLUSTER(n) && contains(CLUSTER(n))) ||
	       (IS_TRIANGLE(n) && contains(TRIANGLE(n))) ||
	       (IS_SUBTRIANGLE(n) && contains(n->grandpa));
}

void Object::detectBounds()
{
	Vec3* vertex = new Vec3[vertices];
	for(unsigned i=0;i<vertices;i++)
	{
		real* v = importer->getVertex(i);
		vertex[i].x = v[0];
		vertex[i].y = v[1];
		vertex[i].z = v[2];
	}
	bound.detect(vertex,vertices);
	delete vertex;
}

void Object::transformBound()
{
	bound.center=bound.centerBeforeTransformation.transformed(transformMatrix);
}

void Scene::transformObjects()
{
	for(unsigned o=0;o<objects;o++)
	{
		// transformuje jen kdyz se matice od minule zmenila
		if(object[o]->matrixDirty)
		{
			// transformuje ted jen sphere a pak vsechny paprsky
			object[o]->transformBound();
			object[o]->matrixDirty=false;
		}
	}
}

void Object::buildClusters()
{
	assert(edge);
	assert(!cluster);

	// build toplevel (maximal size) clusters plus subclusters
	clusters=0;
	cluster=new Cluster[2*edges];
	int freeEdges=0;
	for(unsigned e=0;e<edges;e++)
	{
		edge[e].free=edge[e].angle<=MAX_CLUSTER_ANGLE_B;
		if(edge[e].free) freeEdges++;
	}
	for(unsigned t=0;t<triangles;t++)
	{
		assert(!triangle[t].isInCluster);
		assert(!triangle[t].parent);
	}
	while(freeEdges)
	{
		assert(clusters<2*edges);
		for(unsigned e=0;e<edges;e++) if(edge[e].free)
		{
			// find toplevel and split to subclusters
			int cledges=cluster[clusters].buildAround(&edge[e],cluster,&clusters,2*edges);
			freeEdges-=cledges;
			break;
		}
		//clusters++;
	}

}

bool Object::check()
{
	for(unsigned c=0;c<clusters;c++) assert(cluster[c].check());
	for(unsigned t=0;t<triangles;t++) assert(triangle[t].check());
	for(unsigned t=0;t<triangles;t++) if(triangle[t].surface)
	{
		assert(triangle[t].topivertex[0]->contains(&triangle[t]));
		assert(triangle[t].topivertex[1]->contains(&triangle[t]));
		assert(triangle[t].topivertex[2]->contains(&triangle[t]));
	}
	return true;
}

//////////////////////////////////////////////////////////////////////////////
//
// scene

Scene::Scene()
#ifdef SUPPORT_DYNAMIC
 : staticReflectors(this)
#endif
{
	allocatedObjects=16;
	object=(Object **)malloc(allocatedObjects*sizeof(Object *));
	staticObjects=0;
	objects=0;
	surface=NULL;
	surfaces=0;
	phase=0;
	improvingStatic=NULL;
	shotsForNewFactors=0;
	shotsAccumulated=0;
	shotsForFactorsTotal=0;
	shotsTotal=0;
	energyEmitedByStatics=Channels(SMALL_ENERGY); //to avoid division by zero in black scene
	energyEmitedByDynamics=Channels(SMALL_ENERGY); //to avoid division by zero in black scene
	improveBig=0.5f;
	improveInaccurate=0.99f;
}

Scene::~Scene()
{
	abortStaticImprovement();
	for(unsigned o=0;o<objects;o++) delete object[o];
	free(object);
	delete[] surface;
}

void Scene::objInsertStatic(Object *o)
{
	if(objects==allocatedObjects)
	{
		size_t oldsize=allocatedObjects*sizeof(Object *);
		allocatedObjects*=2;
		object=(Object **)realloc(object,oldsize,allocatedObjects*sizeof(Object *));
	}
	object[objects++]=object[staticObjects];
	object[staticObjects++]=o;

	staticReflectors.insertObject(o);

	energyEmitedByStatics+=o->energyEmited;
}

void Scene::objRemoveStatic(unsigned o)
{
	assert(o<staticObjects);

	staticReflectors.removeObject(object[o]);

	energyEmitedByStatics-=object[o]->energyEmited;

	object[o]=object[--staticObjects];
	object[staticObjects]=object[--objects];
}

unsigned Scene::objNdx(Object *o)
{
	for(unsigned i=0;i<objects;i++)
	    if(object[i]==o) return i;
	assert(0);
	return 0xffffffff;
}

RRScene::Improvement Scene::resetStaticIllumination(bool resetFactors)
{
	abortStaticImprovement();
	if(resetFactors)
	{
		shotsForFactorsTotal=0;
		shotsTotal=0;
	}
	energyEmitedByStatics=Channels(SMALL_ENERGY);
	energyEmitedByDynamics=Channels(SMALL_ENERGY);
	improveBig=0.5f;
	improveInaccurate=0.99f;
	staticReflectors.removeSubtriangles();
	__preserveFactors=!resetFactors;
	staticReflectors.reset();
	for(unsigned o=0;o<objects;o++) 
	{
		object[o]->resetStaticIllumination();
		staticReflectors.insertObject(object[o]);
	}
	__preserveFactors=false;
	for(unsigned o=0;o<staticObjects;o++) energyEmitedByStatics+=object[o]->energyEmited;
	for(unsigned o=staticObjects;o<objects;o++) energyEmitedByDynamics+=object[o]->energyEmited;

//for(unsigned o=0;o<objects;o++) staticReflectors.insertObject(object[o]);
//printf("----------\n");
	return (energyEmitedByStatics!=Channels(SMALL_ENERGY)) ? RRScene::NOT_IMPROVED : RRScene::FINISHED;
}

void Scene::updateMatrices()
{
	for(unsigned o=0;o<objects;o++) 
	{
		object[o]->updateMatrices();
	}
}

//////////////////////////////////////////////////////////////////////////////
//
// trace ray, reflect from triangles and mark hitpoints
// return amount of power added to scene

Vec3 refract(Vec3 N,Vec3 I,real r)
{
	real ndoti=dot(N,I);
	if(ndoti<0) r=1/r;
	real D2=1-r*r*(1-ndoti*ndoti);
	if(D2>=0)
	{
		real a;
		if(ndoti>=0) a=r*ndoti-sqrt(D2);
		else a=r*ndoti+sqrt(D2);
		return N*a-I*r;
	} else {
		// total internal reflection
		return N*(2*ndoti)-I;
	}
}

unsigned __hitsOuter=0;
unsigned __hitsInner=0;

rrIntersect::RRRay* __ray;

HitChannels Scene::rayTracePhoton(Point3 eye,Vec3 direction,Triangle *skip,void *hitExtension,HitChannels power)
// returns power which will be diffuse reflected (result<=power)
// side effects: inserts hits to diffuse surfaces
{
	assert(IS_VEC3(eye));
	assert(IS_VEC3(direction));
	rrIntersect::RRRay& ray = *__ray;
	ray.flags = rrIntersect::RRRay::FILL_DISTANCE|rrIntersect::RRRay::FILL_SIDE|rrIntersect::RRRay::FILL_POINT2D|rrIntersect::RRRay::FILL_TRIANGLE|rrIntersect::RRRay::SKIP_PRETESTS;
	ray.hitDistanceMin = 0;
	ray.hitDistanceMax = BIG_REAL;
	Triangle *hitTriangle = intersectionStatic(ray,eye,direction,skip);
	if(!hitTriangle)
	{
		// ray left scene and vanished
		return HitChannels(0);
	}
	assert(IS_NUMBER(ray.hitDistance));
	static unsigned s_depth = 0;
	if(s_depth>25) 
	{
		RRSetState(RRSS_DEPTH_OVERFLOWS,RRGetState(RRSS_DEPTH_OVERFLOWS)+1);
		return HitChannels(0);
	}
	s_depth++;
	if(ray.hitOuterSide) __hitsOuter++;else __hitsInner++;
	// otherwise surface with these properties was hit
	RRSideBits *side=&sideBits[hitTriangle->surface->sides][ray.hitOuterSide?0:1];
	assert(side->catchFrom); // check that bad side was not hit
	// calculate power of diffuse surface hits
	HitChannels  hitPower=HitChannels(0);
	// diffuse reflection
	// no real reflection is done here, but energy is stored for further
	//  redistribution along existing or newly calculated form factors
	// hits with power below 1% are ignored to save a bit of time
	//  without visible loss of quality
	if(side->receiveFrom)
	if(fabs(power*hitTriangle->surface->diffuseReflectance)>0.01 /*&& !hitTriangle->isNeedle*/) // timto je mozne vypnout vypocet nad jehlama, zustanou cerny
	{
		hitPower+=power*hitTriangle->surface->diffuseReflectance;
		Hit hitPoint2d;
#ifdef HITS_FIXED
		hitPoint2d.u=(HITS_UV_TYPE)(HITS_UV_MAX*i_hitU);
		hitPoint2d.v=(HITS_UV_TYPE)(HITS_UV_MAX*i_hitV);
#else
		// prepocet u,v ze souradnic (rightside,leftside)
		//  do *hitPoint2d s ortonormalni bazi (u3,v3)
		hitPoint2d.u=ray.hitPoint2d[0]*hitTriangle->u2.x+ray.hitPoint2d[1]*hitTriangle->v2.x;
		hitPoint2d.v=ray.hitPoint2d[1]*hitTriangle->v2.y;
#endif
		hitPoint2d.setPower(power);
		// put triangle among other hit triangles
		if(!hitTriangle->hits.hits) hitTriangles.insert(hitTriangle);
		// inform subtriangle where and how powerfully it was hit
#ifdef SUPPORT_DYNAMIC
		if(hitExtension) hitTriangle->hits.insert(hitPoint2d,hitExtension);
		else
#endif
			hitTriangle->hits.insert(hitPoint2d);
	}
	// mirror reflection
	// speedup: weaker rays continue less often but with
	//  proportionally increased power
	if(side->reflect)
	if(fabs(power*hitTriangle->surface->specularReflectance)>0.1)
//	if(sqrt(power*material->specularReflectance)*rand()<RAND_MAX)
	{
		// calculate hitpoint
		Point3 hitPoint3d=eye+direction*ray.hitDistance;
		// calculate new direction after ideal mirror reflection
		Vec3 newDirection=hitTriangle->getN3()*(-2*dot(direction,hitTriangle->getN3())/size2(hitTriangle->getN3()))+direction;
		// recursively call this function
		hitPower+=rayTracePhoton(hitPoint3d,newDirection,hitTriangle,hitExtension,/*sqrt*/(power*hitTriangle->surface->specularReflectance));
	}
	// getting through
	// speedup: weaker rays continue less often but with
	//  proportionally increased power
	if(side->transmitFrom)
	if(fabs(power*hitTriangle->surface->specularTransmittance)>0.1)
//	if(sqrt(power*material->specularTransmittance)*rand()<RAND_MAX)
	{
		// calculate hitpoint
		Point3 hitPoint3d=eye+direction*ray.hitDistance;
		// calculate new direction after refraction
		Vec3 newDirection=-refract(hitTriangle->getN3(),direction,hitTriangle->surface->refractionReal);
		// recursively call this function
		hitPower+=rayTracePhoton(hitPoint3d,newDirection,hitTriangle,hitExtension,/*sqrt*/(power*hitTriangle->surface->specularTransmittance));
	}
	s_depth--;
	return hitPower;
}

//////////////////////////////////////////////////////////////////////////////
//
// homogenous filling:
//   generates points that nearly homogenously (low hustota fluctuations) fill some 2d area

class HomogenousFiller
{
	static unsigned num;
public:
	static void Reset() {num=0;}
	static void GetTrianglePoint(real *a,real *b)
	{
		unsigned n=num++;
		static const real dir[4][3]={{0,0,-0.5f},{0,1,0.5f},{0.86602540378444f,-0.5f,0.5f},{-0.86602540378444f,-0.5f,0.5f}};
		real x=0;
		real y=0;
		real dist=1;
		while(n)
		{
			x+=dist*dir[n&3][0];
			y+=dist*dir[n&3][1];
			dist*=dir[n&3][2];
			n>>=2;
		}
		*a=x;
		*b=y;
		//*a=rand()/(RAND_MAX*0.5)-1;
		//*b=rand()/(RAND_MAX*0.5)-1;
	}
	static real GetCirclePoint(real *a,real *b)
	{
		real dist;
		do GetTrianglePoint(a,b); while((dist=*a**a+*b**b)>=SHOOT_FULL_RANGE);
		return dist;
	}
};

unsigned HomogenousFiller::num;
HomogenousFiller filler;

//////////////////////////////////////////////////////////////////////////////
//
// random exiting ray

Triangle* getRandomExitRay(Node *sourceNode, Vec3* src, Vec3* dir)
{
	SubTriangle *source;
	if(IS_CLUSTER(sourceNode))
	{
		source=CLUSTER(sourceNode)->randomTriangle();
	}
	else
	{
		source=SUBTRIANGLE(sourceNode);
	}
	assert(!IS_CLUSTER(source));

	// select random point in source subtriangle
	unsigned u=rand();
	unsigned v=rand();
	if(u+v>RAND_MAX)
	{
		u=RAND_MAX-u;
		v=RAND_MAX-v;
	}
	Point2 srcPoint2=source->uv[0]+source->u2*(u/(real)RAND_MAX)+source->v2*(v/(real)RAND_MAX);
	Point3 srcPoint3=source->grandpa->to3d(srcPoint2);

	Vec3 rayVec3;
	switch(source->grandpa->surface->emittanceType)
	{
	  case diffuseLight:
	    {
	    //area:
#ifdef HOMOGENOUS_FILL
	    real x,y;
	    real cosa=sqrt(1-filler.GetCirclePoint(&x,&y));
#else
	    // select random vector from srcPoint3 to one halfspace
	    // power is assumed to be 1
	    real tmp=(real)rand()/RAND_MAX*SHOOT_FULL_RANGE;
	    real cosa=sqrt(1-tmp);
#endif
	    // emit only inside?
	    if(!sideBits[source->grandpa->surface->sides][0].emitTo && sideBits[source->grandpa->surface->sides][1].emitTo)
	      cosa=-cosa;
	    // emit to both sides?
	    if(sideBits[source->grandpa->surface->sides][0].emitTo && sideBits[source->grandpa->surface->sides][1].emitTo)
	      if((rand()%2)) cosa=-cosa;
	    // don't emit?
	    if(!sideBits[source->grandpa->surface->sides][0].emitTo && !sideBits[source->grandpa->surface->sides][1].emitTo)
	      return NULL;
#ifdef HOMOGENOUS_FILL
	    rayVec3=source->grandpa->getN3()*cosa
	           +source->grandpa->getU3()*x
	           +source->grandpa->getV3()*y;
#else
	    real sina=sqrt( tmp );                  // a = rotation angle from normal to side, sin(a) = distance from center of circle
	    Angle b=rand()*2*M_PI/RAND_MAX;         // b = rotation angle around normal
	    rayVec3=source->grandpa->getN3()*cosa
	           +source->grandpa->getU3()*(sina*cos(b))
	           +source->grandpa->getV3()*(sina*sin(b));
#endif
	    break;
	    }
	    /*
	  case windowhackDirect:
	    {
	    // hack pro okna, prime svetlo od slunce
	    //! todo: udelat predtest overujici ze okno je zvenci osvetlene
	    rayVec3=normalized(Vec3(1,1,1));
	    break;
	    }
	  case windowhackAmbient:
	    {
	    // hack pro okna, rozptylene svetlo, vice shora, mene zdola
	    rayVec3=normalized(Vec3(1,1,1));
	    break;
	    }	    
	  case spotLight:
	    {
	    // hack pro diskolampu, bodovej zdroj je na souradnicich:
	    source->grandpa->surface->diffuseEmittancePoint=Point3(0,0,23);
	    // select vector from diffuseEmittancePoint to srcPoint3
	    // power is assumed to be 1
	    real r=5;
	    Vec3 rndvec=Vec3(rand()*r*2/RAND_MAX-r,rand()*r*2/RAND_MAX-r,rand()*r*2/RAND_MAX-r);
	    rayVec3=normalized(srcPoint3-source->grandpa->surface->diffuseEmittancePoint+rndvec);
	    break;
	    }
	  case spotLight2:
	    {
	    // hack pro dvere, sviti napul vsesmerove a napul smerove
	    // bodovej zdroj za postavou je v bode:
	    source->grandpa->surface->diffuseEmittancePoint=Point3(-900,350,0);
	    // navic muze cast svetla vylitavat normalne vsesmerove
	    real vsesmerovacast=0.6f;
	    if(rand()<RAND_MAX*vsesmerovacast) goto area;
	    real r=30;
	    Vec3 rndvec=Vec3(rand()*r*2/RAND_MAX-r,rand()*r*2/RAND_MAX-r,rand()*r*2/RAND_MAX-r);
	    rayVec3=normalized(srcPoint3-source->grandpa->surface->diffuseEmittancePoint+rndvec);
	    break;
	    }*/
	  default:
	    // jiny typy zatim nejsou podporovany
	    assert(0);
	}
	assert(IS_SIZE1(rayVec3));

#ifdef SUPPORT_TRANSFORMS
	// transform from shooter's objectspace to scenespace
	*src = srcPoint3.transformed(source->grandpa->object->transformMatrix);
	*dir = rayVec3.rotated(source->grandpa->object->transformMatrix);
#ifdef SUPPORT_SCALE
	*dir = normalized(*dir);
#endif
#else
	*src = srcPoint3;
	*dir = rayVec3;
#endif
	return source->grandpa;
}

//////////////////////////////////////////////////////////////////////////////
//
// one shot from subtriangle to whole halfspace

void Scene::shotFromToHalfspace(Node *sourceNode)
{
	__gscene=this;
	Vec3 srcPoint3,rayVec3;
	Triangle* tri=getRandomExitRay(sourceNode,&srcPoint3,&rayVec3);
	// cast ray
	if(tri) rayTracePhoton(srcPoint3,rayVec3,tri,NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
// distribute energy via one factor

static void distributeEnergyViaFactor(Factor *factor,va_list ap)
{
	DBGLINE
	Channels energy=*va_arg(ap,Channels*);
	Reflectors *staticReflectors=va_arg(ap,Reflectors *);

	Node *destination=factor->destination;
	assert(destination);
	assert(factor->power>=0);
	assert(factor->power<=1 || factor->destination->grandpa->surface->specularTransmittance>0); // power>1 may occur only on transparent surfaces
	energy*=factor->power;
	// kdyz miri nad shooterlevel, presmeruje se dolu
	//...
	// nastavi nektery dirty
	//...mozna by jednou stacilo DIRTY_ALL_SUBNODES na cluster a nedistribuovat to dolu do trianglu
	if(IS_CLUSTER(destination))
		CLUSTER(destination)->makeDirty();
	else
		SUBTRIANGLE(destination)->makeDirty();

#ifdef CLEAN_FACTORS
	assert(destination->grandpa);
	assert(destination->grandpa->surface);
	assert(IS_VEC3(*(Vec3*)destination->grandpa->surface->diffuseReflectanceColor));
	energy *= *(Vec3*)destination->grandpa->surface->diffuseReflectanceColor;
#endif
	// pak leze nahoru az k trianglu, do clusteru neni treba
	bool wasLetToDiffuse=false;
	do
	{
		destination->energyDirect+=energy;
		destination->flags|=FLAG_DIRTY_NODE;
		if(destination->shooter && !wasLetToDiffuse)
		{
			destination->shooter->energyToDiffuse+=energy;
			staticReflectors->insert(destination);
			wasLetToDiffuse=true;
		}
		destination=destination->parent;
	}
	while(destination /*&& !IS_CLUSTER(destination)*/); //...proc je to zakomentovany?
	assert(wasLetToDiffuse);
	// stara verze bez zmeny levelu
	//factor->destination->energyToDiffuse+=energy*factor->power;
	DBGLINE
}

//////////////////////////////////////////////////////////////////////////////
//
// read and clear hits, possibly split to subtriangles, set form factors
// return if clustering with brother is possible

static bool setFormFactorsTo(Node *source,Point3 (*sourceVertices)[3],Factors *factors,SubTriangle *destination,Hits *phits,int shots)
{
	DBGLINE
	assert(destination);
	assert(phits);
	if(phits->hits==0) return true;
	Point2 triCentre=destination->uv[0]+(destination->u2+destination->v2)/3;
	real perimeter=destination->perimeter();
	bool doSplit=/*!destination->grandpa->isNeedle && */phits->doSplit(triCentre,perimeter,destination->grandpa);
//	real difBtwAvgHitAndCen=destination->phits->difBtwAvgHitAnd(triCentre);
//	bool doSplit=difBtwAvgHitAndCen*destination->phits->count>perimeter/MESHING;
	if(doSplit)
	{
		DBGLINE
		destination->splitGeometry(NULL);
		DBGLINE
		Hits *phits2=allocHitsLevel();
		destination->splitHits(phits,phits2);
		setFormFactorsTo(source,sourceVertices,factors,SUBTRIANGLE(destination->sub[0]),phits2,shots);
		freeHitsLevel();
		setFormFactorsTo(source,sourceVertices,factors,SUBTRIANGLE(destination->sub[1]),phits,shots);
		DBGLINE
		return false;
	}
	else
	{
		DBGLINE
		real ff;
		/*if(sourceVertices)
		{
			Point3 destinationVertices[3]={destination->to3d(0),destination->to3d(1),destination->to3d(2)};
			ff=FormFactorf((real (*)[3])sourceVertices,3,(real (*)[3])destinationVertices,3);
			assert(ff>=0);
			assert(ff<=1);
		}
		else*/
		{
			ff=phits->totalPower()/shots;
			// ff muze vyjit >1 kdyz se paprsek lame v pruhlednem objektu a nekolikrat zasahne stejny triangl
			//printf("insert %f = %f/%d * %f\n",ff*destination->grandpa->surface->diffuseReflectance,phits->totalPower(),shots,destination->grandpa->surface->diffuseReflectance);
		}
		// hit powers are not multiplied by surface reflectance, it must be done here (premultiplication=loss of precision)
#ifdef CLEAN_FACTORS
		factors->insert(Factor(destination,ff));
#else
		factors->insert(Factor(destination,ff*destination->grandpa->surface->diffuseReflectance));
#endif
		phits->reset();
		DBGLINE
		return true;
	}
}

// vraci jestli se k nodu (trianglu nebo clusteru) existuje nejaka oflagovana
//  cesta zdola od trianglu

bool isFlagAccessible(Node *node)
{
	return IS_TRIANGLE(node) ||
	       ((node->sub[0]->flags&FLAGS_CLUSTERING) && isFlagAccessible(node->sub[0])) ||
	       ((node->sub[1]->flags&FLAGS_CLUSTERING) && isFlagAccessible(node->sub[1]));
}

// oznaci tento node a predky za zamitace clusteringu

static void markPath_deniesClustering(Node *node,va_list ap)
{
	assert(isFlagAccessible(node));
	while(node && !(node->flags&FLAG_DENIES_CLUSTERING))
	{
		node->flags&=~FLAGS_CLUSTERING;
		node->flags|=FLAG_DENIES_CLUSTERING;
		node=node->parent;

	}
}

// oznaci node ze nabizi clustering a vsechny predky ze zvazujou

static void markPath_weighsClustering(Factor *factor,va_list ap)
{
	Node *node=factor->destination;
	assert(isFlagAccessible(node));
	assert(!(node->flags&FLAGS_CLUSTERING));
	node->flags|=FLAG_OFFERS_CLUSTERING;
	assert(!node->shooter->tmpFactor);
	node->shooter->tmpFactor=factor;
	while(node->parent && !(node->parent->flags&FLAGS_CLUSTERING))
	{
		node=node->parent;
		node->flags|=FLAG_WEIGHS_CLUSTERING;
	}
}

// vycisti flagy tomuto nodu a vsem jeho predkum

static void markPath_clean(Triangle *triangle,va_list ap)
{
	Node *node=triangle;
	do
	{
		node->flags&=~FLAGS_CLUSTERING;
		assert(node->shooter);
		node->shooter->tmpFactor=NULL;
		node=node->parent;
	}
	while(node && (node->flags&FLAGS_CLUSTERING));
}

#ifndef CLEAN_FACTORS
static void goCandidateGo(Factor *factor,va_list ap)
{
	unsigned shots=va_arg(ap,unsigned);

	// kdo jsou candidates?
	//  nody ktery nabizej slouceni(clustering)
	//   zpocatku jen slabe zasazeny triangly
	//   pozdeji nektery vypadavaj a jsou nahrazeny clusterem
	// zpracovani candidates
	//  parent zamita slouceni -> koncime tam kde jsme
	//  bratr vaha -> zastavime kde jsme, bratr nas pozdejc vyveze
	//   az pojede sam nahoru nebo nas necha kdyz nepojede
	//  bratr nabizi -> lze se spojit a jit nahoru
	//  bratr neoflagovany -> nebyl zasazen, lze jit nahoru
	Node *node=factor->destination;
	// "smazany" faktor ignorujeme
	if(!factor->destination) return;
	//Factors *candidatesForClustering=va_arg(ap,Factors *);
go_node_go:
	// [node nabizi propagaci nahoru]
	assert(node->parent);
	assert(!(node->flags&FLAG_DENIES_CLUSTERING));
	// co na to parent?
	if(node->parent->flags&FLAG_DENIES_CLUSTERING)
	{
		// [bratr spojeni odmita (od nej to vi parent)]
		// nas faktor nechame v candidatesForClustering kde uz zustane
		return;
	}
	Node *brother=node->brother();
	if(brother->flags&FLAG_WEIGHS_CLUSTERING)
	{
		// [bratr vaha]
		// nas faktor nechame v candidatesForClustering,
		//  bratr si ho pozdejc muze vyzvednout a vyvezt nas vys
		//  ted jen oznamime ze nabizime clustering
		assert((node->parent->flags&FLAGS_CLUSTERING)==FLAG_WEIGHS_CLUSTERING);
		node->flags&=~FLAGS_CLUSTERING;
		node->flags|=FLAG_OFFERS_CLUSTERING;
		// aby nas pak mel kdo smazat, musi byt oflagovano dole
		assert(isFlagAccessible(node));
		//  a kde mame faktor
		assert(!node->shooter->tmpFactor || node->shooter->tmpFactor==factor);
		node->shooter->tmpFactor=factor;
		return;
	}
	Factor *brotherFactor;
	real brotherPower;
	if(brother->flags&FLAG_OFFERS_CLUSTERING)
	{
		// [bratr nabizi spojeni]
		// mohlo by se jit nahoru
		// zjistime faktor bratra, je kdesi v candidatesForClustering
		brotherFactor=brother->shooter->tmpFactor;
		assert(brotherFactor);
		assert(brotherFactor->power);
		assert(brotherFactor->destination==brother);
		brotherPower=brotherFactor->power;
	}
	else
	{
		// [bratr vubec nezasazen]
		// mohlo by se jit nahoru
		assert((brother->flags&FLAGS_CLUSTERING)==0);
		assert((node->parent->flags&FLAGS_CLUSTERING)==FLAG_WEIGHS_CLUSTERING);
		brotherFactor=NULL;
		brotherPower=0;
	}
	// spocitame zda je vhodne slouceni
	bool propagate=ABS(factor->power-brotherPower)*shots<=1;
//	bool propagate=fabs(factor->power/node->surface->diffuseReflectance
//	                      -brotherPower/brother->surface->diffuseReflectance)*shots<=1;
/*
bug: kdyz ma cluster casti o ruzny difuznosti, strilej=svitej vsechny stejne!
naprava: faktor by mel byt opravdu faktor a energie se prenasobit
	 shooter_surface.diffuseReflectance az pri strileni,
	 misto energyToDiffuse mit energyReceivedToDiffuse,
	 misto energyDiffused mit energyReceivedDiffused,
	 ale problem: u clusteru nejde stanovit accuracy protoze nevi kolik
	  ma opravdu vystrilet
fake naprava: zakazat clustery z ruznych materialu
*/
	if(!propagate)
	{
		// [spojeni by slo ale neni vhodne]
		// oznamime, ze tady se uz nepropaguje
		markPath_deniesClustering(node,ap);
	}
	else
	{
		// [je cas nas a bratra zclusterovat]
		// nasemu faktoru v candidates predelame destination
		factor->destination=node->parent;
		// nasemu faktoru v candidates predelame power
		factor->power+=brotherPower;
		// odstranime bratra z candidatesForClustering
		if(brotherFactor)
		{
			// jen oznacime faktor k pozdejsimu smazani
			// zatim na faktory existuji odkazy, nemuzeme
			//  posledni faktor vzit a prepsat jim tenhle
			//  protoze nevime jestli na posledni nekdo neukazuje
			brotherFactor->power=0;
			brotherFactor->destination=NULL;
		}
		// provedeme s parentem totez cim prosel node
		node=node->parent;
		if(node->parent) goto go_node_go;
	}
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// refresh form factors from one source to all destinations that need it
// split triangles and subtriangles if needed

void Scene::refreshFormFactorsFromUntil(Node *source,real accuracy,bool endfunc(void *),void *context)
{
	DBGLINE
	if(phase==0)
	{
		DBGLINE
		// prepare shooting
		assert(source->shooter);
		shotsForNewFactors=1+(int)(accuracy*sum(abs(source->shooter->energyDiffused+source->shooter->energyToDiffuse)));
		assert(shotsForNewFactors>source->shooter->shotsForFactors);
		assert(shotsAccumulated==0);
		assert(!hitTriangles.get());
		filler.Reset(); // prepare homogenous shooting
		phase=1;
	}
	if(phase==1)
	{
		DBGLINE
		// shoot
		static unsigned shotsLimit=0;
		while(shotsAccumulated<shotsForNewFactors
			)
		{
			shotFromToHalfspace(source);
			shotsAccumulated++;
			shotsTotal++;
			if(shotsTotal%10==0) if(endfunc(context)) return;
		}
		phase=2;
	}
	if(phase==2)
	{
		DBGLINE
		// kontrola ze jsou flagy opravdu vsude ciste
		for(unsigned o=0;o<objects;o++) assert(object[o]->check());
		assert(improvingFactors.factors()==0);
		assert(candidatesForClustering.factors()==0);
		hitTriangles.holdAmulet();
		phase=3;
	}
	if(phase==3)
	{
		DBGLINE
		// analyze and remove hits and calculate new factors
/*
    zpracovani hitTriangles s plnenim candidates a moles
    moles oflagujou cestu nahoru ze se zamita
    candidates oflagujou cestu nahoru ze tamtudy pujdou
     (jeste se nevi jestli s nabidkou nebo zamitnutim)
    zpracovani candidates
     bratr zamita -> koncime tam kde jsme
     bratr nabizi -> lze se spojit a jit nahoru
     bratr neoflagovany -> nebyl zasazen, lze jit nahoru
     bratr vaha -> zastavime kde jsme, bratr nas pozdejc vyveze az pojede
      sam nahoru nebo nas necha kdyz nepojede
    o(h+c)
*/
		Triangle *hitTriangle;

		while((hitTriangle=hitTriangles.get())
			)
		{
			Point3 sourceVertices[3];
			Point3 (*sourceVerticesPtr)[3]=NULL;
			if(!IS_CLUSTER(source))
			{
				sourceVertices[0]=SUBTRIANGLE(source)->to3d(0);
				sourceVertices[1]=SUBTRIANGLE(source)->to3d(1);
				sourceVertices[2]=SUBTRIANGLE(source)->to3d(2);
				sourceVerticesPtr=&sourceVertices;
			}
			// do improvingFactors sype generovane faktory
			if(setFormFactorsTo(source,sourceVerticesPtr,&improvingFactors,hitTriangle,&hitTriangle->hits,shotsAccumulated) && hitTriangle->parent)
			{
				// pokud nevedou do subtrianglu (krtci),
				// preradi je do candidatesForClustering
				candidatesForClustering.insert(improvingFactors.get());
			}
			else
			{       // pokud vedou do subtrianglu,
				// oznaci vsechny predky ze zamitaj clustering
				va_list ap=0;
				markPath_deniesClustering(hitTriangle,ap);
			}
			// pokud je treba setrit pameti, uvolni buffer po hitech
			hitTriangle->compact();
#ifdef SUPPORT_LIGHTMAP
			hitTriangle->updateLightmapSize(false);
#endif
			if(endfunc(context)) return;
		}
		// kandidati oznacej vsechny svy predky ze zvazujou clustering
		candidatesForClustering.forEach(markPath_weighsClustering);
#ifdef CLEAN_FACTORS
		// pri clean_factors nesmi faktor mirit do clusteru, protoze
		//  potrebujeme energii prenasobit krome sily faktoru jeste odrazivosti cile
		//  a clustery nemaj material (resp kazdy triangl muze mit jiny)
#else
		// propagace candidates
		candidatesForClustering.forEach(goCandidateGo,shotsAccumulated);
#endif
		// skutecny odstraneni "smazanejch" candidates
		candidatesForClustering.removeZeroFactors();
		// hitTriangles a vsechny clustery nad nima si vycistej flagy
		hitTriangles.resurrect();
		hitTriangles.forEach(markPath_clean);
		hitTriangles.reset();
		// kontrola ze jsou flagy opravdu vsude ciste
		for(unsigned o=0;o<objects;o++) assert(object[o]->check());

		// take back energy distributed via old factors
		shotsForFactorsTotal-=source->shooter->shotsForFactors;
		Channels ch(-source->shooter->energyDiffused);
		source->shooter->forEach(distributeEnergyViaFactor,&ch/*-source->shooter->energyDiffused*/,&staticReflectors);
		source->shooter->energyToDiffuse+=source->shooter->energyDiffused;
		source->shooter->energyDiffused=Channels(0);
		source->shooter->shotsForFactors=shotsAccumulated;
		shotsAccumulated=0;
		shotsForFactorsTotal+=source->shooter->shotsForFactors;
		// install new factors
		source->shooter->Factors::reset();
		source->shooter->insert(&improvingFactors);
		improvingFactors.reset();
		source->shooter->insert(&candidatesForClustering);
		candidatesForClustering.reset();
		phase=0;
	}
	DBGLINE
}

real Scene::avgAccuracy()
{
	return (1+shotsForFactorsTotal)/sum(abs(energyEmitedByStatics));//* nema tu byt (Statics+Dynamics)?
}

//////////////////////////////////////////////////////////////////////////////
//
// distribute energy from source
// refresh form factors and split triangles and subtriangles if needed
// return if everything was distributed

Reflectors *__staticReflectors;

bool Scene::energyFromDistributedUntil(Node *source,bool endfunc(void *),void *context)
{

	// refresh unaccurate form factors
/*
	real toDiffuse=fabs(source->shooter->energyToDiffuse);
	real allEnergy=fabs(source->shooter->energyToDiffuse+source->shooter->energyDiffused);
	real distribValue=toDiffuse/(source->shooter->factors+0.5)/DISTRIB_TIME;
	real refreshValue=allEnergy/(source->shooter->shotsForFactors+0.5)/REFRESH_TIME;
	bool needsRefresh=refreshValue>=distribValue;
*/
	assert(__staticReflectors->check());
	bool needsRefresh=true;
	real wantedAccuracy=0; // important only when phase==0, init value only to avoid warning
	if(phase==0)
	{
		real avgAcc=avgAccuracy();
		real nowAcc=source->accuracy();
		// pokud best() opakovane vybira reflektor s vysokou accuracy, nikdo nebude refreshovat faktory
		// proto budem podporovat refresh tim vic cim dele uz nebyl
		// notes: cim vetsi BESTS, tim casteji best vraci neco s velkou presnosti, tj. vhodne jen pro distribuci, ne pro refresh
		//  cim mensi hack, tim casteji needsRefresh vnuti refresh nekomu kdo ho moc nepotrebuje
		//  pocitam ze stav kdy best dlouhodobe chybne vybira facy nepotrebujici refresh
		//   nastava dost zridka, takze muzem dat velky hack, vynuceny refresh prijde az po mnoha distribucich
		//  pocitam ze nikdy dlouhodobe nevybira facy s accuracy>2*avg, tem uz bych refresh nevynutil
		//   protoze distributionsSinceRefresh zvetsuju jen do hack/2
		//   (protoze nutit refresh nekomu kdo ma accuracy>2*avg vede k assertu v refreshi)
		enum {hack=MAX(100,BESTS)};
		static int distributionsSinceRefresh=0; // trick to prevent infinite distribution/no refresh loops
		needsRefresh=nowAcc*(-distributionsSinceRefresh+hack)/hack<avgAcc;
		if(needsRefresh)
		{
			distributionsSinceRefresh=0;
			improveBig=MAX(0.3f,improveBig-0.005f);
			improveInaccurate=MIN(2,improveInaccurate+0.005f);
			// double reflector's current accuracy, but stick in range <avgAccuracy,2*avgAccuracy>
			// this makes both 1-lamp and 1000-lamp scenes to converge acceptably
			wantedAccuracy=(nowAcc<avgAcc)?MAX(2*nowAcc,avgAcc):2*avgAcc;
		}
		else
		{
			if(distributionsSinceRefresh<hack/2) distributionsSinceRefresh++;
			improveBig=MIN(1,improveBig+0.05f);
			improveInaccurate=MAX(0.99f,improveInaccurate-0.05f);
		}
	}
	assert(__staticReflectors->check());
	if(needsRefresh)
	{
		refreshFormFactorsFromUntil(source,wantedAccuracy,endfunc,context); // pokud neni phase==0, prostredni parametr muze byt libovolny
	}
	assert(__staticReflectors->check());
	if(phase==0)
	{
		// distribute energy via form factors
		assert(source->shooter);
		assert(__staticReflectors->check());
		source->shooter->forEach(distributeEnergyViaFactor,&source->shooter->energyToDiffuse,&staticReflectors);
		assert(__staticReflectors->check());
		source->shooter->energyDiffused+=source->shooter->energyToDiffuse;
		source->shooter->energyToDiffuse=Channels(0);
		assert(__staticReflectors->check());
		return true;
	}
	assert(__staticReflectors->check());
	return false;
}

//////////////////////////////////////////////////////////////////////////////
//
// improve global illumination in scene by only distributing energy


bool Scene::distribute(real maxError)
{
	DBGLINE
	//if(phase==3) return false; myslim ze zadna phase nebrani distribuci
	bool distributed=false;
	int steps=0;
	int rezerva=20;
	while(1)
	{
		Node *source=staticReflectors.best(true,0.000001f,0,0);
//if(source) printf(" %f<%f\n",fabs(source->shooter->energyToDiffuse),fabs(maxError*energyEmitedByStatics));
		if(!source || ( sum(abs(source->shooter->energyToDiffuse))<sum(abs(energyEmitedByStatics*maxError)) && !rezerva--)) break;
		assert(source->shooter);
		source->shooter->forEach(distributeEnergyViaFactor,&source->shooter->energyToDiffuse,&staticReflectors);
		source->shooter->energyDiffused+=source->shooter->energyToDiffuse;
		source->shooter->energyToDiffuse=Channels(0);
		steps++;
		distributed=true;
	}
//printf("%i\n",steps);
	DBGLINE
	return distributed;
}

//////////////////////////////////////////////////////////////////////////////
//
// improve global illumination in scene

RRScene::Improvement Scene::improveStatic(bool endfunc(void *), void *context)
{
	DBGLINE
	RRScene::Improvement improved=RRScene::NOT_IMPROVED;
	__staticReflectors=&staticReflectors;
	do
	{
		assert(__staticReflectors->check());
		if(improvingStatic==NULL)
		    improvingStatic=staticReflectors.best(false,avgAccuracy(),improveBig,improveInaccurate);
		if(improvingStatic==NULL) break;
		assert(staticReflectors.check());
		if(energyFromDistributedUntil(improvingStatic,endfunc,context))
		{
		    improvingStatic=NULL;
		    improved=RRScene::IMPROVED;
		}
		assert(__staticReflectors->check());
	}
	while(!endfunc(context));
	DBGLINE
	return improved;
}

//////////////////////////////////////////////////////////////////////////////
//
// abort/shorten/finish previously started improvement

void Scene::abortStaticImprovement()
{
	if(improvingStatic)
	{
		Triangle *hitTriangle;
		while((hitTriangle=hitTriangles.get())) hitTriangle->hits.reset();
		hitTriangles.resurrect();
		hitTriangles.forEach(markPath_clean);
		hitTriangles.reset();
		improvingFactors.reset();
		candidatesForClustering.reset();
		shotsAccumulated=0;
		phase=0;
		improvingStatic=NULL;
		// kontrola ze jsou flagy opravdu vsude ciste
		for(unsigned o=0;o<objects;o++) assert(object[o]->check());
	}
}

// skonci pokud uz je hitu aspon tolikrat vic nez kolik bylo pouzito na stavajici kvalitu

bool Scene::shortenStaticImprovementIfBetterThan(real minimalImprovement)
{
	assert((improvingStatic!=NULL) == (phase!=0));
	if(improvingStatic)
	{
		// za techto podminek at uz dal nestrili
		if(phase==1 && shotsAccumulated>=minimalImprovement*improvingStatic->shooter->shotsForFactors) phase=2;
		// vraci uspech pokud uz nestrili ale jeste neskoncil
		return phase>=2;
	}
	return false;
}

bool falsefunc(void *scene)
{
	return false;
}

bool Scene::finishStaticImprovement()
{
	assert((improvingStatic!=NULL) == (phase!=0));
	if(improvingStatic)
	{
		assert(phase>0);
		real e=energyFromDistributedUntil(improvingStatic,falsefunc,NULL);
		assert(e); e=e;
		assert(phase==0);
		improvingStatic=NULL;
		return true;
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////////
//
// instant radiosity

unsigned Reflectors::getInstantRadiosityPoints(unsigned points, RRScene::InstantRadiosityPoint* point) // point must be allocated by caller
{
#define ENERGY_SIZE(node) sum(abs(node->shooter->energyToDiffuse+node->shooter->energyDiffused))
#define ENERGY(node) (node->shooter->energyToDiffuse+node->shooter->energyDiffused)
	if(!points) return 0;
	if(!nodes) return 0;
	assert(point);
	NodeQ* sortedNode=new NodeQ[nodes];
	real fperp = 0;
	for(unsigned i=0;i<nodes;i++)
	{
		real energy = ENERGY_SIZE(node[i]);
		real fertility = energy;
		fperp+=fertility;
		sortedNode[i].q = fertility;
		sortedNode[i].node = node[i];
	}
	qsort(sortedNode,nodes,sizeof(NodeQ),CompareNodeQ);
	//!!!good order?
	fperp/=points;
	unsigned generatedPoints = 0;
	float acum=fperp/2;
	for(unsigned i=0;i<nodes;i++)
	{
		acum += sortedNode[i].q;
		unsigned generatePoints = 0;
		while(acum>fperp && generatedPoints+generatePoints<points) 
		{
			generatePoints++;
			acum -= fperp;
		}
		for(unsigned j=0;j<generatePoints;j++)
		{
			Triangle* t = getRandomExitRay(sortedNode[i].node,(Vec3*)point[generatedPoints].pos,(Vec3*)point[generatedPoints].norm);
			if(dot(*(Vec3*)point[generatedPoints].norm,t->getN3())>=0)
				*(Vec3*)point[generatedPoints].norm = t->getN3();
			else
				*(Vec3*)point[generatedPoints].norm = -t->getN3();
			Channels c = ENERGY(sortedNode[i].node)/generatePoints;
#if CHANNELS==1
			*(Vec3*)point[generatedPoints].col = Vec3(c,c,c);
#else
			*(Vec3*)point[generatedPoints].col = c;
#endif
			generatedPoints++;
		}
	}
	delete[] sortedNode;
	return generatedPoints;
#undef ENERGY_SIZE
#undef ENERGY
}

unsigned Scene::getInstantRadiosityPoints(unsigned n, RRScene::InstantRadiosityPoint* point)
{
	return staticReflectors.getInstantRadiosityPoints(n,point);
}

//////////////////////////////////////////////////////////////////////////////
//
// infos

void Scene::infoScene(char *buf)
{
	int t=0,v=0;
	for(unsigned o=0;o<objects;o++)
	{
		t+=object[o]->triangles;
		v+=object[o]->vertices;
	}
	sprintf(buf,"vertices=%d triangles=%d objects=%d",v,t,objects);
}

void Scene::infoStructs(char *buf)
{
	int no=sizeof(Node);
	int cl=sizeof(Cluster);
	int su=sizeof(SubTriangle);
	int tr=sizeof(Triangle);
	int hi=sizeof(Hit);
	int fa=sizeof(Factor);
	int iv=0;
	int co=0;
	int ed=0;
	iv=sizeof(IVertex);
	co=sizeof(Corner);
	ed=sizeof(Edge);
	sprintf(buf,"no=%i,cl=%i,su=%i,tr=%i  hi=%i,fa=%i  iv=%i,co=%i,ed=%i)",no,cl,su,tr, hi,fa, iv,co,ed);
}

void Scene::infoImprovement(char *buf, int infolevel)
{
	int kb=0;
	int hi=sizeof(Hit)*__hitsAllocated;
	int fa=sizeof(Factor)*__factorsAllocated;
	int su=sizeof(SubTriangle)*(__subtrianglesAllocated-__trianglesAllocated);
	int tr=sizeof(Triangle)*__trianglesAllocated;
	int cl=sizeof(Cluster)*__clustersAllocated;
	int iv=0;
	int co=0;
	int li=0;
	iv=sizeof(IVertex)*__iverticesAllocated;
	co=sizeof(Corner)*__cornersAllocated;
#ifdef SUPPORT_LIGHTMAP
	li=__lightmapsAllocated;
#endif
	int ot=kb-hi-fa-su-tr-cl-iv-co-li;
	buf[0]=0;
	if(infolevel>1) sprintf(buf+strlen(buf),"hits(%i/%i) ",__hitsOuter,__hitsInner);
#ifdef SUPPORT_DYNAMIC
	if(infolevel>1) sprintf(buf+strlen(buf),"dshots(%i->%i) ",__lightShotsPerDynamicFrame,__shadeShotsPerDynamicFrame);
#endif
	//sprintf(buf+strlen(buf),"kb=%i",kb/1024);
	if(infolevel>1) sprintf(buf+strlen(buf),"(hi=%i,fa=%i,su=%i,tr=%i,cl=%i,iv=%i,co=%i,li=%i,ot=%i)",
		hi/1024,fa/1024,su/1024,tr/1024,cl/1024,iv/1024,co/1024,li/1024,ot/1024);
	// sprintf(buf+strlen(buf),"ib=%f ",(double)improveBig);
	// sprintf(buf+strlen(buf),"ii=%f ",(double)improveInaccurate);
	sprintf(buf+strlen(buf)," meshes=%i/%i rays=(%i)%i",staticReflectors.nodes,__nodesAllocated,shotsTotal,shotsForFactorsTotal);
	if(improvingStatic) sprintf(buf+strlen(buf),"(%i/%i->%i)",shotsAccumulated,improvingStatic->shooter->shotsForFactors,shotsForNewFactors);
	assert((improvingStatic!=NULL) == (phase!=0));
}

void core_Done()
{
	assert(__levels);
	delete __levels;
	__levels=NULL;
	delete __ray;
	__ray=NULL;
#ifndef NDEBUG
	if( __nodesAllocated
	 || __subtrianglesAllocated
	 || __trianglesAllocated
	 || __clustersAllocated
	 || __edgesAllocated
	 || __hitsAllocated
	 || __factorsAllocated
	 || __iverticesAllocated
	 || __cornersAllocated
	#ifdef SUPPORT_LIGHTMAP
	 || __lightmapsAllocated
	#endif
	  )
	{
	  fprintf(stderr," nodes       =%8d %8dK\n subtriangles=%8d %8dK\n triangles   =%8d %8dK\n clusters    =%8d %8dK\n edges       =%8d %8dK\n hits        =%8d %8dK\n factors     =%8d %8dK\n",
	    __nodesAllocated,__nodesAllocated*sizeof(Node)/1024,
	    __subtrianglesAllocated,__subtrianglesAllocated*sizeof(SubTriangle)/1024,
	    __trianglesAllocated,__trianglesAllocated*sizeof(Triangle)/1024,
	    __clustersAllocated,__clustersAllocated*sizeof(Cluster)/1024,
	    __edgesAllocated,__edgesAllocated*sizeof(Edge)/1024,
	    __hitsAllocated,__hitsAllocated*sizeof(Hit)/1024,
	    __factorsAllocated,__factorsAllocated*sizeof(Factor)/1024);
	  fprintf(stderr," ivertices   =%8d %8dK\n corners     =%8d %8dK\n",
	    __iverticesAllocated,__iverticesAllocated*sizeof(IVertex)/1024,
	    __cornersAllocated,__cornersAllocated*sizeof(Corner)/1024);
	#ifdef SUPPORT_LIGHTMAP
	  fprintf(stderr," lightmaps   =         %8dK\n",
	    __lightmapsAllocated/1024);
	#endif
	}
#endif

}

void core_Init()
{
	assert(!__levels);
	__levels=new LevelHits();
	__ray = rrIntersect::RRRay::create();
}

#endif

} // namespace
